[2026-01-03 22:33:53] local.DEBUG: üöÄ Livewire initializing... {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:33:52.788Z"} 
[2026-01-03 22:33:53] local.DEBUG: Livewire object exists: true {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:33:52.789Z"} 
[2026-01-03 22:33:53] local.DEBUG: DOM loaded - Livewire available: true {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:33:52.790Z"} 
[2026-01-03 22:33:53] local.DEBUG: After timeout - Livewire exists: true {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:33:52.890Z"} 
[2026-01-03 22:34:38] local.DEBUG: üöÄ Livewire initializing... {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:34:38.222Z"} 
[2026-01-03 22:34:38] local.DEBUG: DOM loaded - Livewire available: true {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:34:38.223Z"} 
[2026-01-03 22:34:38] local.DEBUG: ‚úì Setting up Livewire hooks manually {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:34:38.223Z"} 
[2026-01-03 22:34:38] local.DEBUG: ‚úì Hooks configured {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:34:38.223Z"} 
[2026-01-03 22:35:00] local.DEBUG: üöÄ Livewire initializing... {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:35:00.467Z"} 
[2026-01-03 22:35:00] local.DEBUG: DOM loaded - Livewire available: true {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:35:00.468Z"} 
[2026-01-03 22:35:00] local.DEBUG: Alpine available: true {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:35:00.468Z"} 
[2026-01-03 22:35:00] local.DEBUG: ‚úì Setting up Livewire hooks manually {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:35:00.468Z"} 
[2026-01-03 22:35:00] local.DEBUG: ‚úì Hooks configured {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:35:00.468Z"} 
[2026-01-03 22:35:00] local.DEBUG: Livewire components: 0 {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:35:00.468Z"} 
[2026-01-03 22:35:33] local.DEBUG: üöÄ Livewire initializing... {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:35:33.360Z"} 
[2026-01-03 22:35:33] local.DEBUG: DOM loaded - Livewire available: true {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:35:33.361Z"} 
[2026-01-03 22:35:33] local.DEBUG: Alpine available: true {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:35:33.361Z"} 
[2026-01-03 22:35:33] local.DEBUG: ‚úì Setting up Livewire hooks manually {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:35:33.361Z"} 
[2026-01-03 22:35:33] local.DEBUG: ‚úì Hooks configured {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:35:33.361Z"} 
[2026-01-03 22:35:33] local.DEBUG: Livewire components (before rescan): 0 {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:35:33.361Z"} 
[2026-01-03 22:35:33] local.DEBUG: Livewire components (after rescan): 0 {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:35:33.463Z"} 
[2026-01-03 22:36:14] local.DEBUG: üöÄ Livewire initializing... {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:36:14.443Z"} 
[2026-01-03 22:36:14] local.DEBUG: ‚úì livewire:init event fired {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:36:14.445Z"} 
[2026-01-03 22:36:14] local.DEBUG: DOM loaded - Livewire available: true {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:36:14.447Z"} 
[2026-01-03 22:36:14] local.DEBUG: Alpine available: true {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:36:14.447Z"} 
[2026-01-03 22:36:14] local.DEBUG: ‚úì Setting up Livewire hooks manually {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:36:14.448Z"} 
[2026-01-03 22:36:14] local.DEBUG: ‚úì Hooks configured {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:36:14.448Z"} 
[2026-01-03 22:36:14] local.DEBUG: Livewire components (before rescan): 1 {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:36:14.448Z"} 
[2026-01-03 22:36:14] local.DEBUG: Livewire components (after rescan): 1 {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:36:14.549Z"} 
[2026-01-03 22:36:14] local.DEBUG: [0] g8AxjHNI1duqxsvagIWk company-search {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:36:14.549Z"} 
[2026-01-03 22:36:20] local.DEBUG: üì§ Livewire request:  {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:36:20.303Z"} 
[2026-01-03 22:36:32] local.DEBUG: üì§ Livewire request:  {"url":"https://info-firme.test/","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-03T22:36:32.565Z"} 
[2026-01-04 07:30:53] local.INFO: %cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools font-weight:bold {"url":"https://info-firme.test/companie/410272","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-04T07:30:53.681Z"} 
[2026-01-04 07:30:53] local.DEBUG: Laravel Client PHP 12.44.0 8.3.29 ParseError 1767511853 syntax error, unexpected end of file    /Users/tudor/Projects/info-firme/resources/views/components/seo-meta.blade.php 94 require null "postalCode": "{{ $company->address->postalCode ?? '' }}", "addressCountry": "RO" } @endif @if($company->info && $company->info->phone) ,"telephone": "{{ $company->info->phone }}" @endif } </script> @else <!-- Schema.org for Website with Search Action --> <script type="application/ld+json"> { "@context": "https://schema.org", "@type": "WebSite", "name": "lista-firme.info", "url": "{{ url('/') }}", "description": "CƒÉutare »ôi descoperire de informa»õii despre companii rom√¢ne»ôti", "potentialAction": { "@type": "SearchAction", "target": { "@type": "EntryPoint", "urlTemplate": "{{ url('/') }}?search={search_term_string}" }, "query-input": "required name=search_term_string" } } </script> @endif null  true /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php 123 Illuminate\Filesystem\{closure} Illuminate\Filesystem\Filesystem * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */ public function getRequire($path, array $data = []) { if ($this->isFile($path)) { $__path = $path; $__data = $data; null return (static function () use ($__path, $__data) { extract($__data, EXTR_SKIP); null return require $__path; })(); } null throw new FileNotFoundException("File does not exist at path {$path}."); } null /** * Require the given file once. * * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException arg0 /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php 124 getRequire Illuminate\Filesystem\Filesystem * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */ public function getRequire($path, array $data = []) { if ($this->isFile($path)) { $__path = $path; $__data = $data; null return (static function () use ($__path, $__data) { extract($__data, EXTR_SKIP); null return require $__path; })(); } null throw new FileNotFoundException("File does not exist at path {$path}."); } null /** * Require the given file once. * * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */  false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Engines/PhpEngine.php 57 evaluatePath Illuminate\View\Engines\PhpEngine * * @param  string  $path * @param  array  $data * @return string */ protected function evaluatePath($path, $data) { $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or // an exception is thrown. This prevents any partial views from leaking. try { $this->files->getRequire($path, $data); } catch (Throwable $e) { $this->handleViewException($e, $obLevel); } null return ltrim(ob_get_clean()); } null /** * Handle a view exception. * * @param  \Throwable  $e * @param  int  $obLevel * @return void * path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php 22 evaluatePath Livewire\Mechanisms\ExtendBlade\ExtendedCompilerEngine class ExtendedCompilerEngine extends \Illuminate\View\Engines\CompilerEngine { public function get($path, array $data = []) { if (! ExtendBlade::isRenderingLivewireComponent()) return parent::get($path, $data); null $currentComponent = ExtendBlade::currentRendering(); null trigger('view:compile', $currentComponent, $path); null return parent::get($path, $data); } null protected function evaluatePath($__path, $__data) { if (! ExtendBlade::isRenderingLivewireComponent()) { return parent::evaluatePath($__path, $__data); } null $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or // an exception is thrown. This prevents any partial views from leaking. try { $component = ExtendBlade::currentRendering(); null \Closure::bind(function () use ($__path, $__data) { extract($__data, EXTR_SKIP); path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Engines/CompilerEngine.php 76 get Illuminate\View\Engines\CompilerEngine { $this->lastCompiled[] = $path; null // If this given view has expired, which means it has simply been edited since // it was last compiled, we will re-compile the views so we can evaluate a // fresh copy of the view. We'll pass the compiler the path of the view. if (! isset($this->compiledOrNotExpired[$path]) && $this->compiler->isExpired($path)) { $this->compiler->compile($path); } null // Once we have the path to the compiled file, we will evaluate the paths with // typical PHP just like any other templates. We also keep a stack of views // which have been rendered for right exception messages to be generated. null try { $results = $this->evaluatePath($this->compiler->getCompiledPath($path), $data); } catch (ViewException $e) { if (! Str::of($e->getMessage())->contains(['No such file or directory', 'File does not exist at path'])) { throw $e; } null if (! isset($this->compiledOrNotExpired[$path])) { throw $e; } null $this->compiler->compile($path); null $results = $this->evaluatePath($this->compiler->getCompiledPath($path), $data); } null __path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false __data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php 10 get Livewire\Mechanisms\ExtendBlade\ExtendedCompilerEngine <?php null namespace Livewire\Mechanisms\ExtendBlade; null use function Livewire\trigger; null class ExtendedCompilerEngine extends \Illuminate\View\Engines\CompilerEngine { public function get($path, array $data = []) { if (! ExtendBlade::isRenderingLivewireComponent()) return parent::get($path, $data); null $currentComponent = ExtendBlade::currentRendering(); null trigger('view:compile', $currentComponent, $path); null return parent::get($path, $data); } null protected function evaluatePath($__path, $__data) { if (! ExtendBlade::isRenderingLivewireComponent()) { return parent::evaluatePath($__path, $__data); } null $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/ViewEngineDecorator.php 47 get Sentry\Laravel\Tracing\ViewEngineDecorator null // If there is no sampled span there is no need to wrap the engine call if ($parentSpan === null || !$parentSpan->getSampled()) { return $this->engine->get($path, $data); } null $span = $parentSpan->startChild( SpanContext::make() ->setOp('view.render') ->setOrigin('auto.view') ->setDescription($this->viewFactory->shared(self::SHARED_KEY, basename($path))) ); null SentrySdk::getCurrentHub()->setSpan($span); null $result = $this->engine->get($path, $data); null $span->finish(); null SentrySdk::getCurrentHub()->setSpan($parentSpan); null return $result; } null public function __call($name, $arguments) { return $this->engine->{$name}(...$arguments); } } null path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 208 getContents Illuminate\View\View // Once we've finished rendering the view, we'll decrement the render count // so that each section gets flushed out next time a view is created and // no old sections are staying around in the memory of an environment. $this->factory->decrementRender(); null return $contents; } null /** * Get the evaluated contents of the view. * * @return string */ protected function getContents() { return $this->engine->get($this->path, $this->gatherData()); } null /** * Get the data bound to the view instance. * * @return array */ public function gatherData() { $data = array_merge($this->factory->getShared(), $this->data); null foreach ($data as $key => $value) { if ($value instanceof Renderable) { $data[$key] = $value->render(); path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 191 renderContents Illuminate\View\View null /** * Get the contents of the view instance. * * @return string */ protected function renderContents() { // We will keep track of the number of views being rendered so we can flush // the section after the complete rendering operation is done. This will // clear out the sections for any separate views that may be rendered. $this->factory->incrementRender(); null $this->factory->callComposer($this); null $contents = $this->getContents(); null // Once we've finished rendering the view, we'll decrement the render count // so that each section gets flushed out next time a view is created and // no old sections are staying around in the memory of an environment. $this->factory->decrementRender(); null return $contents; } null /** * Get the evaluated contents of the view. * * @return string */  false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 160 render Illuminate\View\View { return (new Collection($this->render(fn () => $this->factory->getFragments())))->implode(''); } null /** * Get the string contents of the view. * * @param  callable|null  $callback * @return string * * @throws \Throwable */ public function render(?callable $callback = null) { try { $contents = $this->renderContents(); null $response = isset($callback) ? $callback($this, $contents) : null; null // Once we have the contents of the view, we will flush the sections if we are // done rendering all views so that there is nothing left hanging over when // another view gets rendered in the future by the application developer. $this->factory->flushStateIfDoneRendering(); null return ! is_null($response) ? $response : $contents; } catch (Throwable $e) { $this->factory->flushState(); null throw $e; }  false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Response.php 78 setContent Illuminate\Http\Response // from routes that will be automatically transformed to their JSON form. if ($this->shouldBeJson($content)) { $this->header('Content-Type', 'application/json'); null $content = $this->morphToJson($content); null if ($content === false) { throw new InvalidArgumentException(json_last_error_msg()); } } null // If this content implements the "Renderable" interface then we will call the // render method on the object so we will avoid any "__toString" exceptions // that might be thrown and have their errors obscured by PHP's handling. elseif ($content instanceof Renderable) { $content = $content->render(); } null parent::setContent($content); null return $this; } null /** * Determine if the given content should be turned into JSON. * * @param  mixed  $content * @return bool */ protected function shouldBeJson($content) callback null null false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Response.php 34 __construct Illuminate\Http\Response } null /** * Create a new HTTP response. * * @param  mixed  $content * @param  int  $status * @param  array  $headers * * @throws \InvalidArgumentException */ public function __construct($content = '', $status = 200, array $headers = []) { $this->headers = new ResponseHeaderBag($headers); null $this->setContent($content); $this->setStatusCode($status); $this->setProtocolVersion('1.0'); } null /** * Get the response content. */ #[\Override] public function getContent(): string|false { return transform(parent::getContent(), fn ($content) => $content, ''); } null /** null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 939 toResponse Illuminate\Routing\Router if ($response instanceof PsrResponseInterface) { $response = (new HttpFoundationFactory)->createResponse($response); } elseif ($response instanceof Model && $response->wasRecentlyCreated) { $response = new JsonResponse($response, 201); } elseif ($response instanceof Stringable) { $response = new Response($response->__toString(), 200, ['Content-Type' => 'text/html']); } elseif (! $response instanceof SymfonyResponse && ($response instanceof Arrayable || $response instanceof Jsonable || $response instanceof ArrayObject || $response instanceof JsonSerializable || $response instanceof stdClass || is_array($response))) { $response = new JsonResponse($response); } elseif (! $response instanceof SymfonyResponse) { $response = new Response($response, 200, ['Content-Type' => 'text/html']); } null if ($response->getStatusCode() === Response::HTTP_NOT_MODIFIED) { $response->setNotModified(); } null return $response->prepare($request); } null /** * Substitute the route bindings onto the route. * * @param  \Illuminate\Routing\Route  $route * @return \Illuminate\Routing\Route null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 906 prepareResponse Illuminate\Routing\Router { return (new SortedMiddleware($this->middlewarePriority, $middlewares))->all(); } null /** * Create a response instance from the given value. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @param  mixed  $response * @return \Symfony\Component\HttpFoundation\Response */ public function prepareResponse($request, $response) { $this->events->dispatch(new PreparingResponse($request, $response)); null return tap(static::toResponse($request, $response), function ($response) use ($request) { $this->events->dispatch(new ResponsePrepared($request, $response)); }); } null /** * Static version of prepareResponse. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @param  mixed  $response * @return \Symfony\Component\HttpFoundation\Response */ public static function toResponse($request, $response) { if ($response instanceof Responsable) { null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 821 Illuminate\Routing\{closure} Illuminate\Routing\Router * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; null $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddleware($route); null return (new Pipeline($this->container)) ->send($request) ->through($middleware) ->then(fn ($request) => $this->prepareResponse( $request, $route->run() )); } null /** * Gather the middleware for the given route with resolved class names. * * @param  \Illuminate\Routing\Route  $route * @return array */ public function gatherRouteMiddleware(Route $route) { return $this->resolveMiddleware($route->gatherMiddleware(), $route->excludedMiddleware()); } null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 180 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline $this->finally = $callback; null return $this; } null /** * Get the final piece of the Closure onion. * * @param  \Closure  $destination * @return \Closure */ protected function prepareDestination(Closure $destination) { return function ($passable) use ($destination) { try { return $destination($passable); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; } null /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() { return function ($stack, $pipe) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/boost/src/Middleware/InjectBoost.php 22 handle Laravel\Boost\Middleware\InjectBoost use Closure; use Illuminate\Http\JsonResponse; use Illuminate\Http\RedirectResponse; use Illuminate\Http\Request; use Illuminate\View\View; use Laravel\Boost\Services\BrowserLogger; use Symfony\Component\HttpFoundation\BinaryFileResponse; use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpFoundation\StreamedResponse; null class InjectBoost { public function handle(Request $request, Closure $next): Response { /** @var Response $response */ $response = $next($request); null if ($this->shouldInject($response)) { $originalView = $response->original ?? null; $injectedContent = $this->injectScript($response->getContent()); $response->setContent($injectedContent); null if ($originalView instanceof View && property_exists($response, 'original')) { $response->original = $originalView; } } null return $response; } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:178-184 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Middleware/SubstituteBindings.php 50 handle Illuminate\Routing\Middleware\SubstituteBindings { $this->router = $router; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $route = $request->route(); null try { $this->router->substituteBindings($route); $this->router->substituteImplicitBindings($route); } catch (ModelNotFoundException $exception) { if ($route->getMissing()) { return $route->getMissing()($request, $exception); } null throw $exception; } null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/VerifyCsrfToken.php 87 handle Illuminate\Foundation\Http\Middleware\VerifyCsrfToken * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Illuminate\Session\TokenMismatchException */ public function handle($request, Closure $next) { if ( $this->isReading($request) || $this->runningUnitTests() || $this->inExceptArray($request) || $this->tokensMatch($request) ) { return tap($next($request), function ($response) use ($request) { if ($this->shouldAddXsrfTokenCookie()) { $this->addCookieToResponse($request, $response); } }); } null throw new TokenMismatchException('CSRF token mismatch.'); } null /** * Determine if the HTTP request uses a ‚Äòread‚Äô verb. * * @param  \Illuminate\Http\Request  $request * @return bool arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Middleware/ShareErrorsFromSession.php 48 handle Illuminate\View\Middleware\ShareErrorsFromSession */ public function __construct(ViewFactory $view) { $this->view = $view; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { // If the current session has an "errors" variable bound to it, we will share // its value with all view instances so the views can easily access errors // without having to bind. An empty bag is set when there aren't errors. $this->view->share( 'errors', $request->session()->get('errors') ?: new ViewErrorBag ); null // Putting the errors in the view for every view allows the developer to just // assume that some errors are always available, which is convenient since // they don't have to continually run checks for the presence of errors. null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php 120 handleStatefulRequest Illuminate\Session\Middleware\StartSession * @param  \Illuminate\Contracts\Session\Session  $session * @param  \Closure  $next * @return mixed */ protected function handleStatefulRequest(Request $request, $session, Closure $next) { // If a session driver has been configured, we will need to start the session here // so that the data is ready for an application. Note that the Laravel sessions // do not make use of PHP "native" sessions in any way since they are crappy. $request->setLaravelSession( $this->startSession($request, $session) ); null $this->collectGarbage($session); null $response = $next($request); null $this->storeCurrentUrl($request, $session); null $this->addCookieToResponse($response, $session); null // Again, if the session has been configured we will need to close out the session // so that the attributes may be persisted to some storage medium. We will also // add the session identifier cookie to the application response headers now. $this->saveSession($request); null return $response; } null /** arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php 63 handle Illuminate\Session\Middleware\StartSession * @return mixed */ public function handle($request, Closure $next) { if (! $this->sessionConfigured()) { return $next($request); } null $session = $this->getSession($request); null if ($this->manager->shouldBlock() || ($request->route() instanceof Route && $request->route()->locksFor())) { return $this->handleRequestWhileBlocking($request, $session, $next); } null return $this->handleStatefulRequest($request, $session, $next); } null /** * Handle the given request within session state. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Contracts\Session\Session  $session * @param  \Closure  $next * @return mixed */ protected function handleRequestWhileBlocking(Request $request, $session, Closure $next) { if (! $request->route() instanceof Route) { return; request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false session object Illuminate\Session\Store false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Cookie/Middleware/AddQueuedCookiesToResponse.php 36 handle Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse null /** * Create a new CookieQueue instance. * * @param  \Illuminate\Contracts\Cookie\QueueingFactory  $cookies */ public function __construct(CookieJar $cookies) { $this->cookies = $cookies; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); null foreach ($this->cookies->getQueuedCookies() as $cookie) { $response->headers->setCookie($cookie); } null return $response; } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Cookie/Middleware/EncryptCookies.php 74 handle Illuminate\Cookie\Middleware\EncryptCookies */ public function disableFor($name) { $this->except = array_merge($this->except, (array) $name); } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return \Symfony\Component\HttpFoundation\Response */ public function handle($request, Closure $next) { return $this->encrypt($next($this->decrypt($request))); } null /** * Decrypt the cookies on the request. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @return \Symfony\Component\HttpFoundation\Request */ protected function decrypt(Request $request) { foreach ($request->cookies as $key => $cookie) { if ($this->isDisabled($key)) { continue; } arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 137 then Illuminate\Pipeline\Pipeline /** * Run the pipeline with a final destination callback. * * @param  \Closure  $destination * @return mixed */ public function then(Closure $destination) { $pipeline = array_reduce( array_reverse($this->pipes()), $this->carry(), $this->prepareDestination($destination) ); null try { return $this->withinTransaction !== false ? $this->getContainer()->make('db')->connection($this->withinTransaction)->transaction(fn () => $pipeline($this->passable)) : $pipeline($this->passable); } finally { if ($this->finally) { ($this->finally)($this->passable); } } } null /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 821 runRouteWithinStack Illuminate\Routing\Router * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; null $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddleware($route); null return (new Pipeline($this->container)) ->send($request) ->through($middleware) ->then(fn ($request) => $this->prepareResponse( $request, $route->run() )); } null /** * Gather the middleware for the given route with resolved class names. * * @param  \Illuminate\Routing\Route  $route * @return array */ public function gatherRouteMiddleware(Route $route) { return $this->resolveMiddleware($route->gatherMiddleware(), $route->excludedMiddleware()); } destination /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php:821-823 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 800 runRoute Illuminate\Routing\Router null /** * Return the response for the given route. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Routing\Route  $route * @return \Symfony\Component\HttpFoundation\Response */ protected function runRoute(Request $request, Route $route) { $request->setRouteResolver(fn () => $route); null $this->events->dispatch(new RouteMatched($route, $request)); null return $this->prepareResponse($request, $this->runRouteWithinStack($route, $request) ); } null /** * Run the given route within a Stack "onion" instance. * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; route object Illuminate\Routing\Route false false false request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 764 dispatchToRoute Illuminate\Routing\Router public function dispatch(Request $request) { $this->currentRequest = $request; null return $this->dispatchToRoute($request); } null /** * Dispatch the request to a route and return the response. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatchToRoute(Request $request) { return $this->runRoute($request, $this->findRoute($request)); } null /** * Find the route matching a given request. * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Routing\Route */ protected function findRoute($request) { $this->events->dispatch(new Routing($request)); null $this->current = $route = $this->routes->match($request); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false route object Illuminate\Routing\Route false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 753 dispatch Illuminate\Routing\Router $route = tap($this->routes->getByName($name))->bind($this->currentRequest); null return $this->runRoute($this->currentRequest, $route); } null /** * Dispatch the request to the application. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatch(Request $request) { $this->currentRequest = $request; null return $this->dispatchToRoute($request); } null /** * Dispatch the request to a route and return the response. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatchToRoute(Request $request) { return $this->runRoute($request, $this->findRoute($request)); } null /** request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 200 Illuminate\Foundation\Http\{closure} Illuminate\Foundation\Http\Kernel if (! $this->app->hasBeenBootstrapped()) { $this->app->bootstrapWith($this->bootstrappers()); } } null /** * Get the route dispatcher callback. * * @return \Closure */ protected function dispatchToRouter() { return function ($request) { $this->app->instance('request', $request); null return $this->router->dispatch($request); }; } null /** * Call the terminate method on any terminable middleware. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Http\Response  $response * @return void */ public function terminate($request, $response) { $this->app['events']->dispatch(new Terminating); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 180 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline $this->finally = $callback; null return $this; } null /** * Get the final piece of the Closure onion. * * @param  \Closure  $destination * @return \Closure */ protected function prepareDestination(Closure $destination) { return function ($passable) use ($destination) { try { return $destination($passable); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; } null /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() { return function ($stack, $pipe) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/FlushEventsMiddleware.php 13 handle Sentry\Laravel\Http\FlushEventsMiddleware <?php null namespace Sentry\Laravel\Http; null use Closure; use Illuminate\Http\Request; use Sentry\Laravel\Integration; null class FlushEventsMiddleware { public function handle(Request $request, Closure $next) { return $next($request); } null public function terminate(Request $request, $response): void { Integration::flushEvents(); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:178-184 Closure false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestIpMiddleware.php 45 handle Sentry\Laravel\Http\SetRequestIpMiddleware * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure                 $next * * @return mixed */ public function handle(Request $request, Closure $next) { $container = Container::getInstance(); null if ($container->bound(HubInterface::class)) { /** @var \Sentry\State\HubInterface $sentry */ $sentry = $container->make(HubInterface::class); null $client = $sentry->getClient(); null if ($client !== null && $client->getOptions()->shouldSendDefaultPii()) { $sentry->configureScope(static function (Scope $scope) use ($request): void { $scope->setUser([ 'ip_address' => $request->ip(), ]); }); } } null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestMiddleware.php 31 handle Sentry\Laravel\Http\SetRequestMiddleware */ class SetRequestMiddleware { public function handle(Request $request, Closure $next) { $container = Container::getInstance(); null if ($container->bound(HubInterface::class)) { $psrRequest = $this->resolvePsrRequest($container); null if ($psrRequest !== null) { $container->instance(LaravelRequestFetcher::CONTAINER_PSR7_INSTANCE_KEY, $psrRequest); } } null return $next($request); } null private function resolvePsrRequest(Container $container): ?ServerRequestInterface { try { return $container->make(ServerRequestInterface::class); } catch (Throwable $e) { // Do not crash if there is an exception thrown while resolving the request object } null return null; } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Features/SupportDisablingBackButtonCache/DisableBackButtonCacheMiddleware.php 19 handle Livewire\Features\SupportDisablingBackButtonCache\DisableBackButtonCacheMiddleware null use Closure; use Symfony\Component\HttpFoundation\Response; null class DisableBackButtonCacheMiddleware { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); null if ($response instanceof Response && SupportDisablingBackButtonCache::$disableBackButtonCache){ $response->headers->add([ 'Pragma' => 'no-cache', 'Expires' => 'Fri, 01 Jan 1990 00:00:00 GMT', 'Cache-Control' => 'no-cache, must-revalidate, no-store, max-age=0, private', ]); null // We do flush this in the `SupportDisablingBackButtonCache` hook, but we // need to do it here as well to ensure that unit tests still work... SupportDisablingBackButtonCache::$disableBackButtonCache = false; } null return $response; arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php 21 handle Illuminate\Foundation\Http\Middleware\TransformsRequest use Symfony\Component\HttpFoundation\ParameterBag; null class TransformsRequest { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $this->clean($request); null return $next($request); } null /** * Clean the request's data. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function clean($request) { $this->cleanParameterBag($request->query); null if ($request->isJson()) { $this->cleanParameterBag($request->json()); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ConvertEmptyStringsToNull.php 31 handle Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { foreach (static::$skipCallbacks as $callback) { if ($callback($request)) { return $next($request); } } null return parent::handle($request, $next); } null /** * Transform the given value. * * @param  string  $key * @param  mixed  $value * @return mixed */ protected function transform($key, $value) { return $value === '' ? null : $value; } null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php 21 handle Illuminate\Foundation\Http\Middleware\TransformsRequest use Symfony\Component\HttpFoundation\ParameterBag; null class TransformsRequest { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $this->clean($request); null return $next($request); } null /** * Clean the request's data. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function clean($request) { $this->cleanParameterBag($request->query); null if ($request->isJson()) { $this->cleanParameterBag($request->json()); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TrimStrings.php 51 handle Illuminate\Foundation\Http\Middleware\TrimStrings /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { foreach (static::$skipCallbacks as $callback) { if ($callback($request)) { return $next($request); } } null return parent::handle($request, $next); } null /** * Transform the given value. * * @param  string  $key * @param  mixed  $value * @return mixed */ protected function transform($key, $value) { $except = array_merge($this->except, static::$neverTrim); null if ($this->shouldSkip($key, $except) || ! is_string($value)) { request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/ValidatePostSize.php 27 handle Illuminate\Http\Middleware\ValidatePostSize * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Illuminate\Http\Exceptions\PostTooLargeException */ public function handle($request, Closure $next) { $max = $this->getPostMaxSize(); null if ($max > 0 && $request->server('CONTENT_LENGTH') > $max) { throw new PostTooLargeException('The POST data is too large.'); } null return $next($request); } null /** * Determine the server 'post_max_size' as bytes. * * @return int */ protected function getPostMaxSize() { if (is_numeric($postMaxSize = ini_get('post_max_size'))) { return (int) $postMaxSize; } null $metric = strtoupper(substr($postMaxSize, -1)); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/PreventRequestsDuringMaintenance.php 109 handle Illuminate\Foundation\Http\Middleware\PreventRequestsDuringMaintenance return response( $data['template'], $data['status'] ?? 503, $this->getHeaders($data) ); } null throw new HttpException( $data['status'] ?? 503, 'Service Unavailable', null, $this->getHeaders($data) ); } null return $next($request); } null /** * Determine if the incoming request has a maintenance mode bypass cookie. * * @param  \Illuminate\Http\Request  $request * @param  array  $data * @return bool */ protected function hasValidBypassCookie($request, array $data) { return isset($data['secret']) && $request->cookie('laravel_maintenance') && MaintenanceModeBypassCookie::isValid( arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/HandleCors.php 48 handle Illuminate\Http\Middleware\HandleCors { $this->container = $container; $this->cors = $cors; } null /** * Handle the incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return \Illuminate\Http\Response */ public function handle($request, Closure $next) { if (! $this->hasMatchingPath($request)) { return $next($request); } null $this->cors->setOptions($this->container['config']->get('cors', [])); null if ($this->cors->isPreflightRequest($request)) { $response = $this->cors->handlePreflightRequest($request); null $this->cors->varyHeader($response, 'Access-Control-Request-Method'); null return $response; } null $response = $next($request); null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/TrustProxies.php 58 handle Illuminate\Http\Middleware\TrustProxies /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Symfony\Component\HttpKernel\Exception\HttpException */ public function handle(Request $request, Closure $next) { $request::setTrustedProxies([], $this->getTrustedHeaderNames()); null $this->setTrustedProxyIpAddresses($request); null return $next($request); } null /** * Sets the trusted proxies on the request. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function setTrustedProxyIpAddresses(Request $request) { $trustedIps = $this->proxies() ?: config('trustedproxy.proxies'); null if (is_null($trustedIps) && (laravel_cloud() || arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/Middleware.php 79 handle Sentry\Laravel\Tracing\Middleware null /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * * @return mixed */ public function handle(Request $request, Closure $next) { if (app()->bound(HubInterface::class)) { $this->startTransaction($request); } null return $next($request); } null /** * Handle the application termination. * * @param \Illuminate\Http\Request $request * @param mixed $response * * @return void */ public function terminate(Request $request, $response): void { // If there is no transaction there is nothing for us to do if ($this->transaction === null) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 137 then Illuminate\Pipeline\Pipeline /** * Run the pipeline with a final destination callback. * * @param  \Closure  $destination * @return mixed */ public function then(Closure $destination) { $pipeline = array_reduce( array_reverse($this->pipes()), $this->carry(), $this->prepareDestination($destination) ); null try { return $this->withinTransaction !== false ? $this->getContainer()->make('db')->connection($this->withinTransaction)->transaction(fn () => $pipeline($this->passable)) : $pipeline($this->passable); } finally { if ($this->finally) { ($this->finally)($this->passable); } } } null /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 175 sendRequestThroughRouter Illuminate\Foundation\Http\Kernel * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Http\Response */ protected function sendRequestThroughRouter($request) { $this->app->instance('request', $request); null Request::clearResolvedInstance(); null $this->bootstrap(); null return (new Pipeline($this->app)) ->send($request) ->through($this->app->shouldSkipMiddleware() ? [] : $this->middleware) ->then($this->dispatchToRouter()); } null /** * Bootstrap the application for HTTP requests. * * @return void */ public function bootstrap() { if (! $this->app->hasBeenBootstrapped()) { $this->app->bootstrapWith($this->bootstrappers()); } } null destination /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php:197-201 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 144 handle Illuminate\Foundation\Http\Kernel } null /** * Handle an incoming HTTP request. * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Http\Response */ public function handle($request) { $this->requestStartedAt = Carbon::now(); null try { $request->enableHttpMethodParameterOverride(); null $response = $this->sendRequestThroughRouter($request); } catch (Throwable $e) { $this->reportException($e); null $response = $this->renderException($request, $e); } null $this->app['events']->dispatch( new RequestHandled($request, $response) ); null return $response; } null /** request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/public/index.php 51 require null | | Composer provides a convenient, automatically generated class loader for | this application. We just need to utilize it! We'll simply require it | into the script here so we don't need to manually load our classes. | */ null require __DIR__.'/../vendor/autoload.php'; null /* |-------------------------------------------------------------------------- | Run The Application |-------------------------------------------------------------------------- | | Once we have the application, we can handle the incoming request using | the application's HTTP kernel. Then, we will send the response back | to this client's browser, allowing them to enjoy our application. | */ null $app = require_once __DIR__.'/../bootstrap/app.php'; null $kernel = $app->make(Kernel::class); null $response = $kernel->handle( $request = Request::capture() )->send(); null $kernel->terminate($request, $response); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false true /Users/tudor/.composer/vendor/laravel/valet/server.php 110 [top] null $isPhpFile = pathinfo($uri, PATHINFO_EXTENSION) === 'php'; null if ($uri !== '/' && ! $isPhpFile && $staticFilePath = $valetDriver->isStaticFile($valetSitePath, $siteName, $uri)) { return $valetDriver->serveStaticFile($staticFilePath, $valetSitePath, $siteName, $uri); } null /** * Allow for drivers to take pre-loading actions (e.g. setting server variables). */ $valetDriver->beforeLoading($valetSitePath, $siteName, $uri); null /** * Attempt to dispatch to a front controller. */ $frontControllerPath = $valetDriver->frontControllerPath( $valetSitePath, $siteName, $uri ); null if (! $frontControllerPath) { if (isset($valetConfig['directory-listing']) && $valetConfig['directory-listing'] == 'on') { Server::showDirectoryListing($valetSitePath, $uri); } null Server::show404(); } null chdir(dirname($frontControllerPath)); null require $frontControllerPath; null  true https://info-firme.test/companie/410272 null GET Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36    info-firme.test <CENSORED> u=0, i en-US,en;q=0.9 gzip, deflate, br, zstd document ?1 navigate none text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36 1 "macOS" ?0 "Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24" uAXsyM05tx1x32aTeC4WkDxaO0P7k8tYKjJmZ84J vM3se5WQ0HWW2xKJndqeDDnC0KAHLR7OtAe15Hss uAXsyM05tx1x32aTeC4WkDxaO0P7k8tYKjJmZ84J https://info-firme.test/sitemap-1.xml null   company.show 410272 App\Http\Controllers\CompanyController@show web /Users/tudor/Projects/info-firme/resources/views/components/seo-meta.blade.php <pre class=sf-dump id=sf-dump-1862492123 data-indent-pad="  "><span class=sf-dump-note>Illuminate\Support\ViewErrorBag</span> {<a class=sf-dump-ref>#1342</a><samp data-depth=1 class=sf-dump-expanded>
  #<span class=sf-dump-protected title="Protected property">bags</span>: []
</samp>}
</pre><script>Sfdump("sf-dump-1862492123", {"maxDepth":3,"maxStringLength":160})</script> <pre class=sf-dump id=sf-dump-1064693183 data-indent-pad="  ">"<span class=sf-dump-str title="14 characters">companies.show</span>"
</pre><script>Sfdump("sf-dump-1064693183", {"maxDepth":3,"maxStringLength":160})</script> <pre class=sf-dump id=sf-dump-1224189652 data-indent-pad="  "><span class=sf-dump-note>App\Models\Company</span> {<a class=sf-dump-ref>#982</a><samp data-depth=1 class=sf-dump-expanded>
  #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
  #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="9 characters">companies</span>"
  #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
  #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
  +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
  #<span class=sf-dump-protected title="Protected property">with</span>: []
  #<span class=sf-dump-protected title="Protected property">withCount</span>: []
  +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
  +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
  +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:12</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>id</span>" => <span class=sf-dump-num>3</span>
    "<span class=sf-dump-key>name</span>" => "<span class=sf-dump-str title="23 characters">COLIU IMPORT EXPORT SRL</span>"
    "<span class=sf-dump-key>cui</span>" => "<span class=sf-dump-str title="6 characters">410272</span>"
    "<span class=sf-dump-key>euid</span>" => "<span class=sf-dump-str title="20 characters">ROONRC.J40/5712/1992</span>"
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="19 characters">1992-03-11 17:31:22</span>"
    "<span class=sf-dump-key>type</span>" => "<span class=sf-dump-str title="3 characters">SRL</span>"
    "<span class=sf-dump-key>website</span>" => ""
    "<span class=sf-dump-key>parent_country</span>" => ""
    "<span class=sf-dump-key>mark</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>reg_com</span>" => "<span class=sf-dump-str title="13 characters">J40/5712/1992</span>"
    "<span class=sf-dump-key>created_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
    "<span class=sf-dump-key>updated_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:12</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>id</span>" => <span class=sf-dump-num>3</span>
    "<span class=sf-dump-key>name</span>" => "<span class=sf-dump-str title="23 characters">COLIU IMPORT EXPORT SRL</span>"
    "<span class=sf-dump-key>cui</span>" => "<span class=sf-dump-str title="6 characters">410272</span>"
    "<span class=sf-dump-key>euid</span>" => "<span class=sf-dump-str title="20 characters">ROONRC.J40/5712/1992</span>"
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="19 characters">1992-03-11 17:31:22</span>"
    "<span class=sf-dump-key>type</span>" => "<span class=sf-dump-str title="3 characters">SRL</span>"
    "<span class=sf-dump-key>website</span>" => ""
    "<span class=sf-dump-key>parent_country</span>" => ""
    "<span class=sf-dump-key>mark</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>reg_com</span>" => "<span class=sf-dump-str title="13 characters">J40/5712/1992</span>"
    "<span class=sf-dump-key>created_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
    "<span class=sf-dump-key>updated_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">changes</span>: []
  #<span class=sf-dump-protected title="Protected property">previous</span>: []
  #<span class=sf-dump-protected title="Protected property">casts</span>: <span class=sf-dump-note>array:1</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="4 characters">date</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
  #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
  #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
  #<span class=sf-dump-protected title="Protected property">appends</span>: []
  #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
  #<span class=sf-dump-protected title="Protected property">observables</span>: []
  #<span class=sf-dump-protected title="Protected property">relations</span>: <span class=sf-dump-note>array:7</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>address</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="App\Models\Address
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">App\Models</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Address</span></span> {<a class=sf-dump-ref>#2496</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
      #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="9 characters">addresses</span>"
      #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
      #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
      +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
      #<span class=sf-dump-protected title="Protected property">with</span>: []
      #<span class=sf-dump-protected title="Protected property">withCount</span>: []
      +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
      +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:16</span> [ &#8230;16]
      #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:16</span> [ &#8230;16]
      #<span class=sf-dump-protected title="Protected property">changes</span>: []
      #<span class=sf-dump-protected title="Protected property">previous</span>: []
      #<span class=sf-dump-protected title="Protected property">casts</span>: []
      #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">appends</span>: []
      #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
      #<span class=sf-dump-protected title="Protected property">observables</span>: []
      #<span class=sf-dump-protected title="Protected property">relations</span>: []
      #<span class=sf-dump-protected title="Protected property">touches</span>: []
      #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
      +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:4</span> [ &#8230;4]
      #<span class=sf-dump-protected title="Protected property">visible</span>: []
      #<span class=sf-dump-protected title="Protected property">fillable</span>: []
      #<span class=sf-dump-protected title="Protected property">guarded</span>: []
    </samp>}
    "<span class=sf-dump-key>info</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>status</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="App\Models\Status
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">App\Models</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Status</span></span> {<a class=sf-dump-ref>#2504</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
      #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="8 characters">statuses</span>"
      #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
      #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
      +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
      #<span class=sf-dump-protected title="Protected property">with</span>: []
      #<span class=sf-dump-protected title="Protected property">withCount</span>: []
      +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
      +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">changes</span>: []
      #<span class=sf-dump-protected title="Protected property">previous</span>: []
      #<span class=sf-dump-protected title="Protected property">casts</span>: []
      #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">appends</span>: []
      #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
      #<span class=sf-dump-protected title="Protected property">observables</span>: []
      #<span class=sf-dump-protected title="Protected property">relations</span>: <span class=sf-dump-note>array:1</span> [ &#8230;1]
      #<span class=sf-dump-protected title="Protected property">touches</span>: []
      #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
      +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">visible</span>: []
      #<span class=sf-dump-protected title="Protected property">fillable</span>: <span class=sf-dump-note>array:2</span> [ &#8230;2]
      #<span class=sf-dump-protected title="Protected property">guarded</span>: <span class=sf-dump-note>array:1</span> [ &#8230;1]
    </samp>}
    "<span class=sf-dump-key>caen</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#2499</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>legalRepresentatives</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#2545</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>naturalPersonRepresentatives</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#2552</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>euBranches</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#2559</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
  </samp>]
  #<span class=sf-dump-protected title="Protected property">touches</span>: []
  #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
  #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
  +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
  +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:3</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str title="10 characters">created_at</span>"
    <span class=sf-dump-index>1</span> => "<span class=sf-dump-str title="10 characters">updated_at</span>"
    <span class=sf-dump-index>2</span> => "<span class=sf-dump-str title="2 characters">id</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">visible</span>: []
  #<span class=sf-dump-protected title="Protected property">fillable</span>: <span class=sf-dump-note>array:10</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str title="4 characters">name</span>"
    <span class=sf-dump-index>1</span> => "<span class=sf-dump-str title="3 characters">cui</span>"
    <span class=sf-dump-index>2</span> => "<span class=sf-dump-str title="7 characters">reg_com</span>"
    <span class=sf-dump-index>3</span> => "<span class=sf-dump-str title="4 characters">euid</span>"
    <span class=sf-dump-index>4</span> => "<span class=sf-dump-str title="6 characters">status</span>"
    <span class=sf-dump-index>5</span> => "<span class=sf-dump-str title="17 characters">registration_date</span>"
    <span class=sf-dump-index>6</span> => "<span class=sf-dump-str title="4 characters">type</span>"
    <span class=sf-dump-index>7</span> => "<span class=sf-dump-str title="7 characters">website</span>"
    <span class=sf-dump-index>8</span> => "<span class=sf-dump-str title="14 characters">parent_country</span>"
    <span class=sf-dump-index>9</span> => "<span class=sf-dump-str title="4 characters">mark</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">guarded</span>: <span class=sf-dump-note>array:1</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str>*</span>"
  </samp>]
</samp>}
</pre><script>Sfdump("sf-dump-1224189652", {"maxDepth":3,"maxStringLength":160})</script> 8.3.29 12.44.0 ro false true local a5562107215ff05a7fc40849695aea476b6008f5 Optimizare SEO: pagini individuale companii, meta taguri, harta siteului »ôi favicon v1.0 git@github.com:tudorr89/info-firme.git true   select * from `companies` where `cui` = ? limit 1 4.67 mysql 410272 1767511853.1373 select * from `addresses` where `addresses`.`company_id` in (3) 2.34 mysql  1767511853.143 select * from `infos` where `infos`.`company_id` in (3) 1.6 mysql  1767511853.1454 select * from `statuses` where `statuses`.`registration` in (?) 3.22 mysql J40/5712/1992 1767511853.1493 select * from `nomenclators` where `nomenclators`.`code` in (?) 1.52 mysql 1084 1767511853.1523 select * from `caen_companies` where `caen_companies`.`registration` in (?) 2.53 mysql J40/5712/1992 1767511853.1563 select * from `legal_representatives` where `legal_representatives`.`registration` in (?) 1.66 mysql J40/5712/1992 1767511853.1588 select * from `natural_person_representatives` where `natural_person_representatives`.`registration` in (?) 1.28 mysql J40/5712/1992 1767511853.1607 select * from `e_u_branches` where `e_u_branches`.`registration` in (?) 1.16 mysql J40/5712/1992 1767511853.1626 local null null /Users/tudor/Projects/info-firme null 86b4fc4d-55b5-473b-a1bc-e836efd51c36 null null Laravel Client PHP 12.44.0 8.3.29 ParseError 1767511853 syntax error, unexpected end of file    /Users/tudor/Projects/info-firme/resources/views/components/seo-meta.blade.php 94 require null "postalCode": "{{ $company->address->postalCode ?? '' }}", "addressCountry": "RO" } @endif @if($company->info && $company->info->phone) ,"telephone": "{{ $company->info->phone }}" @endif } </script> @else <!-- Schema.org for Website with Search Action --> <script type="application/ld+json"> { "@context": "https://schema.org", "@type": "WebSite", "name": "lista-firme.info", "url": "{{ url('/') }}", "description": "CƒÉutare »ôi descoperire de informa»õii despre companii rom√¢ne»ôti", "potentialAction": { "@type": "SearchAction", "target": { "@type": "EntryPoint", "urlTemplate": "{{ url('/') }}?search={search_term_string}" }, "query-input": "required name=search_term_string" } } </script> @endif null  true /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php 123 Illuminate\Filesystem\{closure} Illuminate\Filesystem\Filesystem * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */ public function getRequire($path, array $data = []) { if ($this->isFile($path)) { $__path = $path; $__data = $data; null return (static function () use ($__path, $__data) { extract($__data, EXTR_SKIP); null return require $__path; })(); } null throw new FileNotFoundException("File does not exist at path {$path}."); } null /** * Require the given file once. * * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException arg0 /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php 124 getRequire Illuminate\Filesystem\Filesystem * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */ public function getRequire($path, array $data = []) { if ($this->isFile($path)) { $__path = $path; $__data = $data; null return (static function () use ($__path, $__data) { extract($__data, EXTR_SKIP); null return require $__path; })(); } null throw new FileNotFoundException("File does not exist at path {$path}."); } null /** * Require the given file once. * * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */  false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Engines/PhpEngine.php 57 evaluatePath Illuminate\View\Engines\PhpEngine * * @param  string  $path * @param  array  $data * @return string */ protected function evaluatePath($path, $data) { $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or // an exception is thrown. This prevents any partial views from leaking. try { $this->files->getRequire($path, $data); } catch (Throwable $e) { $this->handleViewException($e, $obLevel); } null return ltrim(ob_get_clean()); } null /** * Handle a view exception. * * @param  \Throwable  $e * @param  int  $obLevel * @return void * path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php 22 evaluatePath Livewire\Mechanisms\ExtendBlade\ExtendedCompilerEngine class ExtendedCompilerEngine extends \Illuminate\View\Engines\CompilerEngine { public function get($path, array $data = []) { if (! ExtendBlade::isRenderingLivewireComponent()) return parent::get($path, $data); null $currentComponent = ExtendBlade::currentRendering(); null trigger('view:compile', $currentComponent, $path); null return parent::get($path, $data); } null protected function evaluatePath($__path, $__data) { if (! ExtendBlade::isRenderingLivewireComponent()) { return parent::evaluatePath($__path, $__data); } null $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or // an exception is thrown. This prevents any partial views from leaking. try { $component = ExtendBlade::currentRendering(); null \Closure::bind(function () use ($__path, $__data) { extract($__data, EXTR_SKIP); path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Engines/CompilerEngine.php 76 get Illuminate\View\Engines\CompilerEngine { $this->lastCompiled[] = $path; null // If this given view has expired, which means it has simply been edited since // it was last compiled, we will re-compile the views so we can evaluate a // fresh copy of the view. We'll pass the compiler the path of the view. if (! isset($this->compiledOrNotExpired[$path]) && $this->compiler->isExpired($path)) { $this->compiler->compile($path); } null // Once we have the path to the compiled file, we will evaluate the paths with // typical PHP just like any other templates. We also keep a stack of views // which have been rendered for right exception messages to be generated. null try { $results = $this->evaluatePath($this->compiler->getCompiledPath($path), $data); } catch (ViewException $e) { if (! Str::of($e->getMessage())->contains(['No such file or directory', 'File does not exist at path'])) { throw $e; } null if (! isset($this->compiledOrNotExpired[$path])) { throw $e; } null $this->compiler->compile($path); null $results = $this->evaluatePath($this->compiler->getCompiledPath($path), $data); } null __path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false __data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php 10 get Livewire\Mechanisms\ExtendBlade\ExtendedCompilerEngine <?php null namespace Livewire\Mechanisms\ExtendBlade; null use function Livewire\trigger; null class ExtendedCompilerEngine extends \Illuminate\View\Engines\CompilerEngine { public function get($path, array $data = []) { if (! ExtendBlade::isRenderingLivewireComponent()) return parent::get($path, $data); null $currentComponent = ExtendBlade::currentRendering(); null trigger('view:compile', $currentComponent, $path); null return parent::get($path, $data); } null protected function evaluatePath($__path, $__data) { if (! ExtendBlade::isRenderingLivewireComponent()) { return parent::evaluatePath($__path, $__data); } null $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/ViewEngineDecorator.php 47 get Sentry\Laravel\Tracing\ViewEngineDecorator null // If there is no sampled span there is no need to wrap the engine call if ($parentSpan === null || !$parentSpan->getSampled()) { return $this->engine->get($path, $data); } null $span = $parentSpan->startChild( SpanContext::make() ->setOp('view.render') ->setOrigin('auto.view') ->setDescription($this->viewFactory->shared(self::SHARED_KEY, basename($path))) ); null SentrySdk::getCurrentHub()->setSpan($span); null $result = $this->engine->get($path, $data); null $span->finish(); null SentrySdk::getCurrentHub()->setSpan($parentSpan); null return $result; } null public function __call($name, $arguments) { return $this->engine->{$name}(...$arguments); } } null path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 208 getContents Illuminate\View\View // Once we've finished rendering the view, we'll decrement the render count // so that each section gets flushed out next time a view is created and // no old sections are staying around in the memory of an environment. $this->factory->decrementRender(); null return $contents; } null /** * Get the evaluated contents of the view. * * @return string */ protected function getContents() { return $this->engine->get($this->path, $this->gatherData()); } null /** * Get the data bound to the view instance. * * @return array */ public function gatherData() { $data = array_merge($this->factory->getShared(), $this->data); null foreach ($data as $key => $value) { if ($value instanceof Renderable) { $data[$key] = $value->render(); path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 191 renderContents Illuminate\View\View null /** * Get the contents of the view instance. * * @return string */ protected function renderContents() { // We will keep track of the number of views being rendered so we can flush // the section after the complete rendering operation is done. This will // clear out the sections for any separate views that may be rendered. $this->factory->incrementRender(); null $this->factory->callComposer($this); null $contents = $this->getContents(); null // Once we've finished rendering the view, we'll decrement the render count // so that each section gets flushed out next time a view is created and // no old sections are staying around in the memory of an environment. $this->factory->decrementRender(); null return $contents; } null /** * Get the evaluated contents of the view. * * @return string */  false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 160 render Illuminate\View\View { return (new Collection($this->render(fn () => $this->factory->getFragments())))->implode(''); } null /** * Get the string contents of the view. * * @param  callable|null  $callback * @return string * * @throws \Throwable */ public function render(?callable $callback = null) { try { $contents = $this->renderContents(); null $response = isset($callback) ? $callback($this, $contents) : null; null // Once we have the contents of the view, we will flush the sections if we are // done rendering all views so that there is nothing left hanging over when // another view gets rendered in the future by the application developer. $this->factory->flushStateIfDoneRendering(); null return ! is_null($response) ? $response : $contents; } catch (Throwable $e) { $this->factory->flushState(); null throw $e; }  false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Response.php 78 setContent Illuminate\Http\Response // from routes that will be automatically transformed to their JSON form. if ($this->shouldBeJson($content)) { $this->header('Content-Type', 'application/json'); null $content = $this->morphToJson($content); null if ($content === false) { throw new InvalidArgumentException(json_last_error_msg()); } } null // If this content implements the "Renderable" interface then we will call the // render method on the object so we will avoid any "__toString" exceptions // that might be thrown and have their errors obscured by PHP's handling. elseif ($content instanceof Renderable) { $content = $content->render(); } null parent::setContent($content); null return $this; } null /** * Determine if the given content should be turned into JSON. * * @param  mixed  $content * @return bool */ protected function shouldBeJson($content) callback null null false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Response.php 34 __construct Illuminate\Http\Response } null /** * Create a new HTTP response. * * @param  mixed  $content * @param  int  $status * @param  array  $headers * * @throws \InvalidArgumentException */ public function __construct($content = '', $status = 200, array $headers = []) { $this->headers = new ResponseHeaderBag($headers); null $this->setContent($content); $this->setStatusCode($status); $this->setProtocolVersion('1.0'); } null /** * Get the response content. */ #[\Override] public function getContent(): string|false { return transform(parent::getContent(), fn ($content) => $content, ''); } null /** null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 939 toResponse Illuminate\Routing\Router if ($response instanceof PsrResponseInterface) { $response = (new HttpFoundationFactory)->createResponse($response); } elseif ($response instanceof Model && $response->wasRecentlyCreated) { $response = new JsonResponse($response, 201); } elseif ($response instanceof Stringable) { $response = new Response($response->__toString(), 200, ['Content-Type' => 'text/html']); } elseif (! $response instanceof SymfonyResponse && ($response instanceof Arrayable || $response instanceof Jsonable || $response instanceof ArrayObject || $response instanceof JsonSerializable || $response instanceof stdClass || is_array($response))) { $response = new JsonResponse($response); } elseif (! $response instanceof SymfonyResponse) { $response = new Response($response, 200, ['Content-Type' => 'text/html']); } null if ($response->getStatusCode() === Response::HTTP_NOT_MODIFIED) { $response->setNotModified(); } null return $response->prepare($request); } null /** * Substitute the route bindings onto the route. * * @param  \Illuminate\Routing\Route  $route * @return \Illuminate\Routing\Route null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 906 prepareResponse Illuminate\Routing\Router { return (new SortedMiddleware($this->middlewarePriority, $middlewares))->all(); } null /** * Create a response instance from the given value. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @param  mixed  $response * @return \Symfony\Component\HttpFoundation\Response */ public function prepareResponse($request, $response) { $this->events->dispatch(new PreparingResponse($request, $response)); null return tap(static::toResponse($request, $response), function ($response) use ($request) { $this->events->dispatch(new ResponsePrepared($request, $response)); }); } null /** * Static version of prepareResponse. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @param  mixed  $response * @return \Symfony\Component\HttpFoundation\Response */ public static function toResponse($request, $response) { if ($response instanceof Responsable) { null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 821 Illuminate\Routing\{closure} Illuminate\Routing\Router * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; null $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddleware($route); null return (new Pipeline($this->container)) ->send($request) ->through($middleware) ->then(fn ($request) => $this->prepareResponse( $request, $route->run() )); } null /** * Gather the middleware for the given route with resolved class names. * * @param  \Illuminate\Routing\Route  $route * @return array */ public function gatherRouteMiddleware(Route $route) { return $this->resolveMiddleware($route->gatherMiddleware(), $route->excludedMiddleware()); } null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 180 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline $this->finally = $callback; null return $this; } null /** * Get the final piece of the Closure onion. * * @param  \Closure  $destination * @return \Closure */ protected function prepareDestination(Closure $destination) { return function ($passable) use ($destination) { try { return $destination($passable); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; } null /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() { return function ($stack, $pipe) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/boost/src/Middleware/InjectBoost.php 22 handle Laravel\Boost\Middleware\InjectBoost use Closure; use Illuminate\Http\JsonResponse; use Illuminate\Http\RedirectResponse; use Illuminate\Http\Request; use Illuminate\View\View; use Laravel\Boost\Services\BrowserLogger; use Symfony\Component\HttpFoundation\BinaryFileResponse; use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpFoundation\StreamedResponse; null class InjectBoost { public function handle(Request $request, Closure $next): Response { /** @var Response $response */ $response = $next($request); null if ($this->shouldInject($response)) { $originalView = $response->original ?? null; $injectedContent = $this->injectScript($response->getContent()); $response->setContent($injectedContent); null if ($originalView instanceof View && property_exists($response, 'original')) { $response->original = $originalView; } } null return $response; } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:178-184 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Middleware/SubstituteBindings.php 50 handle Illuminate\Routing\Middleware\SubstituteBindings { $this->router = $router; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $route = $request->route(); null try { $this->router->substituteBindings($route); $this->router->substituteImplicitBindings($route); } catch (ModelNotFoundException $exception) { if ($route->getMissing()) { return $route->getMissing()($request, $exception); } null throw $exception; } null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/VerifyCsrfToken.php 87 handle Illuminate\Foundation\Http\Middleware\VerifyCsrfToken * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Illuminate\Session\TokenMismatchException */ public function handle($request, Closure $next) { if ( $this->isReading($request) || $this->runningUnitTests() || $this->inExceptArray($request) || $this->tokensMatch($request) ) { return tap($next($request), function ($response) use ($request) { if ($this->shouldAddXsrfTokenCookie()) { $this->addCookieToResponse($request, $response); } }); } null throw new TokenMismatchException('CSRF token mismatch.'); } null /** * Determine if the HTTP request uses a ‚Äòread‚Äô verb. * * @param  \Illuminate\Http\Request  $request * @return bool arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Middleware/ShareErrorsFromSession.php 48 handle Illuminate\View\Middleware\ShareErrorsFromSession */ public function __construct(ViewFactory $view) { $this->view = $view; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { // If the current session has an "errors" variable bound to it, we will share // its value with all view instances so the views can easily access errors // without having to bind. An empty bag is set when there aren't errors. $this->view->share( 'errors', $request->session()->get('errors') ?: new ViewErrorBag ); null // Putting the errors in the view for every view allows the developer to just // assume that some errors are always available, which is convenient since // they don't have to continually run checks for the presence of errors. null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php 120 handleStatefulRequest Illuminate\Session\Middleware\StartSession * @param  \Illuminate\Contracts\Session\Session  $session * @param  \Closure  $next * @return mixed */ protected function handleStatefulRequest(Request $request, $session, Closure $next) { // If a session driver has been configured, we will need to start the session here // so that the data is ready for an application. Note that the Laravel sessions // do not make use of PHP "native" sessions in any way since they are crappy. $request->setLaravelSession( $this->startSession($request, $session) ); null $this->collectGarbage($session); null $response = $next($request); null $this->storeCurrentUrl($request, $session); null $this->addCookieToResponse($response, $session); null // Again, if the session has been configured we will need to close out the session // so that the attributes may be persisted to some storage medium. We will also // add the session identifier cookie to the application response headers now. $this->saveSession($request); null return $response; } null /** arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php 63 handle Illuminate\Session\Middleware\StartSession * @return mixed */ public function handle($request, Closure $next) { if (! $this->sessionConfigured()) { return $next($request); } null $session = $this->getSession($request); null if ($this->manager->shouldBlock() || ($request->route() instanceof Route && $request->route()->locksFor())) { return $this->handleRequestWhileBlocking($request, $session, $next); } null return $this->handleStatefulRequest($request, $session, $next); } null /** * Handle the given request within session state. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Contracts\Session\Session  $session * @param  \Closure  $next * @return mixed */ protected function handleRequestWhileBlocking(Request $request, $session, Closure $next) { if (! $request->route() instanceof Route) { return; request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false session object Illuminate\Session\Store false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Cookie/Middleware/AddQueuedCookiesToResponse.php 36 handle Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse null /** * Create a new CookieQueue instance. * * @param  \Illuminate\Contracts\Cookie\QueueingFactory  $cookies */ public function __construct(CookieJar $cookies) { $this->cookies = $cookies; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); null foreach ($this->cookies->getQueuedCookies() as $cookie) { $response->headers->setCookie($cookie); } null return $response; } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Cookie/Middleware/EncryptCookies.php 74 handle Illuminate\Cookie\Middleware\EncryptCookies */ public function disableFor($name) { $this->except = array_merge($this->except, (array) $name); } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return \Symfony\Component\HttpFoundation\Response */ public function handle($request, Closure $next) { return $this->encrypt($next($this->decrypt($request))); } null /** * Decrypt the cookies on the request. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @return \Symfony\Component\HttpFoundation\Request */ protected function decrypt(Request $request) { foreach ($request->cookies as $key => $cookie) { if ($this->isDisabled($key)) { continue; } arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 137 then Illuminate\Pipeline\Pipeline /** * Run the pipeline with a final destination callback. * * @param  \Closure  $destination * @return mixed */ public function then(Closure $destination) { $pipeline = array_reduce( array_reverse($this->pipes()), $this->carry(), $this->prepareDestination($destination) ); null try { return $this->withinTransaction !== false ? $this->getContainer()->make('db')->connection($this->withinTransaction)->transaction(fn () => $pipeline($this->passable)) : $pipeline($this->passable); } finally { if ($this->finally) { ($this->finally)($this->passable); } } } null /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 821 runRouteWithinStack Illuminate\Routing\Router * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; null $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddleware($route); null return (new Pipeline($this->container)) ->send($request) ->through($middleware) ->then(fn ($request) => $this->prepareResponse( $request, $route->run() )); } null /** * Gather the middleware for the given route with resolved class names. * * @param  \Illuminate\Routing\Route  $route * @return array */ public function gatherRouteMiddleware(Route $route) { return $this->resolveMiddleware($route->gatherMiddleware(), $route->excludedMiddleware()); } destination /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php:821-823 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 800 runRoute Illuminate\Routing\Router null /** * Return the response for the given route. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Routing\Route  $route * @return \Symfony\Component\HttpFoundation\Response */ protected function runRoute(Request $request, Route $route) { $request->setRouteResolver(fn () => $route); null $this->events->dispatch(new RouteMatched($route, $request)); null return $this->prepareResponse($request, $this->runRouteWithinStack($route, $request) ); } null /** * Run the given route within a Stack "onion" instance. * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; route object Illuminate\Routing\Route false false false request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 764 dispatchToRoute Illuminate\Routing\Router public function dispatch(Request $request) { $this->currentRequest = $request; null return $this->dispatchToRoute($request); } null /** * Dispatch the request to a route and return the response. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatchToRoute(Request $request) { return $this->runRoute($request, $this->findRoute($request)); } null /** * Find the route matching a given request. * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Routing\Route */ protected function findRoute($request) { $this->events->dispatch(new Routing($request)); null $this->current = $route = $this->routes->match($request); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false route object Illuminate\Routing\Route false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 753 dispatch Illuminate\Routing\Router $route = tap($this->routes->getByName($name))->bind($this->currentRequest); null return $this->runRoute($this->currentRequest, $route); } null /** * Dispatch the request to the application. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatch(Request $request) { $this->currentRequest = $request; null return $this->dispatchToRoute($request); } null /** * Dispatch the request to a route and return the response. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatchToRoute(Request $request) { return $this->runRoute($request, $this->findRoute($request)); } null /** request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 200 Illuminate\Foundation\Http\{closure} Illuminate\Foundation\Http\Kernel if (! $this->app->hasBeenBootstrapped()) { $this->app->bootstrapWith($this->bootstrappers()); } } null /** * Get the route dispatcher callback. * * @return \Closure */ protected function dispatchToRouter() { return function ($request) { $this->app->instance('request', $request); null return $this->router->dispatch($request); }; } null /** * Call the terminate method on any terminable middleware. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Http\Response  $response * @return void */ public function terminate($request, $response) { $this->app['events']->dispatch(new Terminating); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 180 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline $this->finally = $callback; null return $this; } null /** * Get the final piece of the Closure onion. * * @param  \Closure  $destination * @return \Closure */ protected function prepareDestination(Closure $destination) { return function ($passable) use ($destination) { try { return $destination($passable); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; } null /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() { return function ($stack, $pipe) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/FlushEventsMiddleware.php 13 handle Sentry\Laravel\Http\FlushEventsMiddleware <?php null namespace Sentry\Laravel\Http; null use Closure; use Illuminate\Http\Request; use Sentry\Laravel\Integration; null class FlushEventsMiddleware { public function handle(Request $request, Closure $next) { return $next($request); } null public function terminate(Request $request, $response): void { Integration::flushEvents(); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:178-184 Closure false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestIpMiddleware.php 45 handle Sentry\Laravel\Http\SetRequestIpMiddleware * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure                 $next * * @return mixed */ public function handle(Request $request, Closure $next) { $container = Container::getInstance(); null if ($container->bound(HubInterface::class)) { /** @var \Sentry\State\HubInterface $sentry */ $sentry = $container->make(HubInterface::class); null $client = $sentry->getClient(); null if ($client !== null && $client->getOptions()->shouldSendDefaultPii()) { $sentry->configureScope(static function (Scope $scope) use ($request): void { $scope->setUser([ 'ip_address' => $request->ip(), ]); }); } } null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestMiddleware.php 31 handle Sentry\Laravel\Http\SetRequestMiddleware */ class SetRequestMiddleware { public function handle(Request $request, Closure $next) { $container = Container::getInstance(); null if ($container->bound(HubInterface::class)) { $psrRequest = $this->resolvePsrRequest($container); null if ($psrRequest !== null) { $container->instance(LaravelRequestFetcher::CONTAINER_PSR7_INSTANCE_KEY, $psrRequest); } } null return $next($request); } null private function resolvePsrRequest(Container $container): ?ServerRequestInterface { try { return $container->make(ServerRequestInterface::class); } catch (Throwable $e) { // Do not crash if there is an exception thrown while resolving the request object } null return null; } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Features/SupportDisablingBackButtonCache/DisableBackButtonCacheMiddleware.php 19 handle Livewire\Features\SupportDisablingBackButtonCache\DisableBackButtonCacheMiddleware null use Closure; use Symfony\Component\HttpFoundation\Response; null class DisableBackButtonCacheMiddleware { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); null if ($response instanceof Response && SupportDisablingBackButtonCache::$disableBackButtonCache){ $response->headers->add([ 'Pragma' => 'no-cache', 'Expires' => 'Fri, 01 Jan 1990 00:00:00 GMT', 'Cache-Control' => 'no-cache, must-revalidate, no-store, max-age=0, private', ]); null // We do flush this in the `SupportDisablingBackButtonCache` hook, but we // need to do it here as well to ensure that unit tests still work... SupportDisablingBackButtonCache::$disableBackButtonCache = false; } null return $response; arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php 21 handle Illuminate\Foundation\Http\Middleware\TransformsRequest use Symfony\Component\HttpFoundation\ParameterBag; null class TransformsRequest { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $this->clean($request); null return $next($request); } null /** * Clean the request's data. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function clean($request) { $this->cleanParameterBag($request->query); null if ($request->isJson()) { $this->cleanParameterBag($request->json()); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ConvertEmptyStringsToNull.php 31 handle Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { foreach (static::$skipCallbacks as $callback) { if ($callback($request)) { return $next($request); } } null return parent::handle($request, $next); } null /** * Transform the given value. * * @param  string  $key * @param  mixed  $value * @return mixed */ protected function transform($key, $value) { return $value === '' ? null : $value; } null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php 21 handle Illuminate\Foundation\Http\Middleware\TransformsRequest use Symfony\Component\HttpFoundation\ParameterBag; null class TransformsRequest { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $this->clean($request); null return $next($request); } null /** * Clean the request's data. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function clean($request) { $this->cleanParameterBag($request->query); null if ($request->isJson()) { $this->cleanParameterBag($request->json()); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TrimStrings.php 51 handle Illuminate\Foundation\Http\Middleware\TrimStrings /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { foreach (static::$skipCallbacks as $callback) { if ($callback($request)) { return $next($request); } } null return parent::handle($request, $next); } null /** * Transform the given value. * * @param  string  $key * @param  mixed  $value * @return mixed */ protected function transform($key, $value) { $except = array_merge($this->except, static::$neverTrim); null if ($this->shouldSkip($key, $except) || ! is_string($value)) { request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/ValidatePostSize.php 27 handle Illuminate\Http\Middleware\ValidatePostSize * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Illuminate\Http\Exceptions\PostTooLargeException */ public function handle($request, Closure $next) { $max = $this->getPostMaxSize(); null if ($max > 0 && $request->server('CONTENT_LENGTH') > $max) { throw new PostTooLargeException('The POST data is too large.'); } null return $next($request); } null /** * Determine the server 'post_max_size' as bytes. * * @return int */ protected function getPostMaxSize() { if (is_numeric($postMaxSize = ini_get('post_max_size'))) { return (int) $postMaxSize; } null $metric = strtoupper(substr($postMaxSize, -1)); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/PreventRequestsDuringMaintenance.php 109 handle Illuminate\Foundation\Http\Middleware\PreventRequestsDuringMaintenance return response( $data['template'], $data['status'] ?? 503, $this->getHeaders($data) ); } null throw new HttpException( $data['status'] ?? 503, 'Service Unavailable', null, $this->getHeaders($data) ); } null return $next($request); } null /** * Determine if the incoming request has a maintenance mode bypass cookie. * * @param  \Illuminate\Http\Request  $request * @param  array  $data * @return bool */ protected function hasValidBypassCookie($request, array $data) { return isset($data['secret']) && $request->cookie('laravel_maintenance') && MaintenanceModeBypassCookie::isValid( arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/HandleCors.php 48 handle Illuminate\Http\Middleware\HandleCors { $this->container = $container; $this->cors = $cors; } null /** * Handle the incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return \Illuminate\Http\Response */ public function handle($request, Closure $next) { if (! $this->hasMatchingPath($request)) { return $next($request); } null $this->cors->setOptions($this->container['config']->get('cors', [])); null if ($this->cors->isPreflightRequest($request)) { $response = $this->cors->handlePreflightRequest($request); null $this->cors->varyHeader($response, 'Access-Control-Request-Method'); null return $response; } null $response = $next($request); null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/TrustProxies.php 58 handle Illuminate\Http\Middleware\TrustProxies /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Symfony\Component\HttpKernel\Exception\HttpException */ public function handle(Request $request, Closure $next) { $request::setTrustedProxies([], $this->getTrustedHeaderNames()); null $this->setTrustedProxyIpAddresses($request); null return $next($request); } null /** * Sets the trusted proxies on the request. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function setTrustedProxyIpAddresses(Request $request) { $trustedIps = $this->proxies() ?: config('trustedproxy.proxies'); null if (is_null($trustedIps) && (laravel_cloud() || arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/Middleware.php 79 handle Sentry\Laravel\Tracing\Middleware null /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * * @return mixed */ public function handle(Request $request, Closure $next) { if (app()->bound(HubInterface::class)) { $this->startTransaction($request); } null return $next($request); } null /** * Handle the application termination. * * @param \Illuminate\Http\Request $request * @param mixed $response * * @return void */ public function terminate(Request $request, $response): void { // If there is no transaction there is nothing for us to do if ($this->transaction === null) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 137 then Illuminate\Pipeline\Pipeline /** * Run the pipeline with a final destination callback. * * @param  \Closure  $destination * @return mixed */ public function then(Closure $destination) { $pipeline = array_reduce( array_reverse($this->pipes()), $this->carry(), $this->prepareDestination($destination) ); null try { return $this->withinTransaction !== false ? $this->getContainer()->make('db')->connection($this->withinTransaction)->transaction(fn () => $pipeline($this->passable)) : $pipeline($this->passable); } finally { if ($this->finally) { ($this->finally)($this->passable); } } } null /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 175 sendRequestThroughRouter Illuminate\Foundation\Http\Kernel * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Http\Response */ protected function sendRequestThroughRouter($request) { $this->app->instance('request', $request); null Request::clearResolvedInstance(); null $this->bootstrap(); null return (new Pipeline($this->app)) ->send($request) ->through($this->app->shouldSkipMiddleware() ? [] : $this->middleware) ->then($this->dispatchToRouter()); } null /** * Bootstrap the application for HTTP requests. * * @return void */ public function bootstrap() { if (! $this->app->hasBeenBootstrapped()) { $this->app->bootstrapWith($this->bootstrappers()); } } null destination /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php:197-201 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 144 handle Illuminate\Foundation\Http\Kernel } null /** * Handle an incoming HTTP request. * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Http\Response */ public function handle($request) { $this->requestStartedAt = Carbon::now(); null try { $request->enableHttpMethodParameterOverride(); null $response = $this->sendRequestThroughRouter($request); } catch (Throwable $e) { $this->reportException($e); null $response = $this->renderException($request, $e); } null $this->app['events']->dispatch( new RequestHandled($request, $response) ); null return $response; } null /** request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/public/index.php 51 require null | | Composer provides a convenient, automatically generated class loader for | this application. We just need to utilize it! We'll simply require it | into the script here so we don't need to manually load our classes. | */ null require __DIR__.'/../vendor/autoload.php'; null /* |-------------------------------------------------------------------------- | Run The Application |-------------------------------------------------------------------------- | | Once we have the application, we can handle the incoming request using | the application's HTTP kernel. Then, we will send the response back | to this client's browser, allowing them to enjoy our application. | */ null $app = require_once __DIR__.'/../bootstrap/app.php'; null $kernel = $app->make(Kernel::class); null $response = $kernel->handle( $request = Request::capture() )->send(); null $kernel->terminate($request, $response); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false true /Users/tudor/.composer/vendor/laravel/valet/server.php 110 [top] null $isPhpFile = pathinfo($uri, PATHINFO_EXTENSION) === 'php'; null if ($uri !== '/' && ! $isPhpFile && $staticFilePath = $valetDriver->isStaticFile($valetSitePath, $siteName, $uri)) { return $valetDriver->serveStaticFile($staticFilePath, $valetSitePath, $siteName, $uri); } null /** * Allow for drivers to take pre-loading actions (e.g. setting server variables). */ $valetDriver->beforeLoading($valetSitePath, $siteName, $uri); null /** * Attempt to dispatch to a front controller. */ $frontControllerPath = $valetDriver->frontControllerPath( $valetSitePath, $siteName, $uri ); null if (! $frontControllerPath) { if (isset($valetConfig['directory-listing']) && $valetConfig['directory-listing'] == 'on') { Server::showDirectoryListing($valetSitePath, $uri); } null Server::show404(); } null chdir(dirname($frontControllerPath)); null require $frontControllerPath; null  true https://info-firme.test/companie/410272 null GET Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36    info-firme.test <CENSORED> u=0, i en-US,en;q=0.9 gzip, deflate, br, zstd document ?1 navigate none text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36 1 "macOS" ?0 "Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24" uAXsyM05tx1x32aTeC4WkDxaO0P7k8tYKjJmZ84J vM3se5WQ0HWW2xKJndqeDDnC0KAHLR7OtAe15Hss uAXsyM05tx1x32aTeC4WkDxaO0P7k8tYKjJmZ84J https://info-firme.test/sitemap-1.xml null   company.show 410272 App\Http\Controllers\CompanyController@show web /Users/tudor/Projects/info-firme/resources/views/components/seo-meta.blade.php <pre class=sf-dump id=sf-dump-1862492123 data-indent-pad="  "><span class=sf-dump-note>Illuminate\Support\ViewErrorBag</span> {<a class=sf-dump-ref>#1342</a><samp data-depth=1 class=sf-dump-expanded>
  #<span class=sf-dump-protected title="Protected property">bags</span>: []
</samp>}
</pre><script>Sfdump("sf-dump-1862492123", {"maxDepth":3,"maxStringLength":160})</script> <pre class=sf-dump id=sf-dump-1064693183 data-indent-pad="  ">"<span class=sf-dump-str title="14 characters">companies.show</span>"
</pre><script>Sfdump("sf-dump-1064693183", {"maxDepth":3,"maxStringLength":160})</script> <pre class=sf-dump id=sf-dump-1224189652 data-indent-pad="  "><span class=sf-dump-note>App\Models\Company</span> {<a class=sf-dump-ref>#982</a><samp data-depth=1 class=sf-dump-expanded>
  #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
  #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="9 characters">companies</span>"
  #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
  #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
  +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
  #<span class=sf-dump-protected title="Protected property">with</span>: []
  #<span class=sf-dump-protected title="Protected property">withCount</span>: []
  +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
  +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
  +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:12</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>id</span>" => <span class=sf-dump-num>3</span>
    "<span class=sf-dump-key>name</span>" => "<span class=sf-dump-str title="23 characters">COLIU IMPORT EXPORT SRL</span>"
    "<span class=sf-dump-key>cui</span>" => "<span class=sf-dump-str title="6 characters">410272</span>"
    "<span class=sf-dump-key>euid</span>" => "<span class=sf-dump-str title="20 characters">ROONRC.J40/5712/1992</span>"
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="19 characters">1992-03-11 17:31:22</span>"
    "<span class=sf-dump-key>type</span>" => "<span class=sf-dump-str title="3 characters">SRL</span>"
    "<span class=sf-dump-key>website</span>" => ""
    "<span class=sf-dump-key>parent_country</span>" => ""
    "<span class=sf-dump-key>mark</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>reg_com</span>" => "<span class=sf-dump-str title="13 characters">J40/5712/1992</span>"
    "<span class=sf-dump-key>created_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
    "<span class=sf-dump-key>updated_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:12</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>id</span>" => <span class=sf-dump-num>3</span>
    "<span class=sf-dump-key>name</span>" => "<span class=sf-dump-str title="23 characters">COLIU IMPORT EXPORT SRL</span>"
    "<span class=sf-dump-key>cui</span>" => "<span class=sf-dump-str title="6 characters">410272</span>"
    "<span class=sf-dump-key>euid</span>" => "<span class=sf-dump-str title="20 characters">ROONRC.J40/5712/1992</span>"
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="19 characters">1992-03-11 17:31:22</span>"
    "<span class=sf-dump-key>type</span>" => "<span class=sf-dump-str title="3 characters">SRL</span>"
    "<span class=sf-dump-key>website</span>" => ""
    "<span class=sf-dump-key>parent_country</span>" => ""
    "<span class=sf-dump-key>mark</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>reg_com</span>" => "<span class=sf-dump-str title="13 characters">J40/5712/1992</span>"
    "<span class=sf-dump-key>created_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
    "<span class=sf-dump-key>updated_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">changes</span>: []
  #<span class=sf-dump-protected title="Protected property">previous</span>: []
  #<span class=sf-dump-protected title="Protected property">casts</span>: <span class=sf-dump-note>array:1</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="4 characters">date</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
  #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
  #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
  #<span class=sf-dump-protected title="Protected property">appends</span>: []
  #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
  #<span class=sf-dump-protected title="Protected property">observables</span>: []
  #<span class=sf-dump-protected title="Protected property">relations</span>: <span class=sf-dump-note>array:7</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>address</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="App\Models\Address
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">App\Models</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Address</span></span> {<a class=sf-dump-ref>#2496</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
      #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="9 characters">addresses</span>"
      #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
      #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
      +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
      #<span class=sf-dump-protected title="Protected property">with</span>: []
      #<span class=sf-dump-protected title="Protected property">withCount</span>: []
      +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
      +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:16</span> [ &#8230;16]
      #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:16</span> [ &#8230;16]
      #<span class=sf-dump-protected title="Protected property">changes</span>: []
      #<span class=sf-dump-protected title="Protected property">previous</span>: []
      #<span class=sf-dump-protected title="Protected property">casts</span>: []
      #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">appends</span>: []
      #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
      #<span class=sf-dump-protected title="Protected property">observables</span>: []
      #<span class=sf-dump-protected title="Protected property">relations</span>: []
      #<span class=sf-dump-protected title="Protected property">touches</span>: []
      #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
      +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:4</span> [ &#8230;4]
      #<span class=sf-dump-protected title="Protected property">visible</span>: []
      #<span class=sf-dump-protected title="Protected property">fillable</span>: []
      #<span class=sf-dump-protected title="Protected property">guarded</span>: []
    </samp>}
    "<span class=sf-dump-key>info</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>status</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="App\Models\Status
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">App\Models</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Status</span></span> {<a class=sf-dump-ref>#2504</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
      #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="8 characters">statuses</span>"
      #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
      #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
      +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
      #<span class=sf-dump-protected title="Protected property">with</span>: []
      #<span class=sf-dump-protected title="Protected property">withCount</span>: []
      +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
      +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">changes</span>: []
      #<span class=sf-dump-protected title="Protected property">previous</span>: []
      #<span class=sf-dump-protected title="Protected property">casts</span>: []
      #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">appends</span>: []
      #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
      #<span class=sf-dump-protected title="Protected property">observables</span>: []
      #<span class=sf-dump-protected title="Protected property">relations</span>: <span class=sf-dump-note>array:1</span> [ &#8230;1]
      #<span class=sf-dump-protected title="Protected property">touches</span>: []
      #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
      +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">visible</span>: []
      #<span class=sf-dump-protected title="Protected property">fillable</span>: <span class=sf-dump-note>array:2</span> [ &#8230;2]
      #<span class=sf-dump-protected title="Protected property">guarded</span>: <span class=sf-dump-note>array:1</span> [ &#8230;1]
    </samp>}
    "<span class=sf-dump-key>caen</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#2499</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>legalRepresentatives</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#2545</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>naturalPersonRepresentatives</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#2552</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>euBranches</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#2559</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
  </samp>]
  #<span class=sf-dump-protected title="Protected property">touches</span>: []
  #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
  #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
  +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
  +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:3</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str title="10 characters">created_at</span>"
    <span class=sf-dump-index>1</span> => "<span class=sf-dump-str title="10 characters">updated_at</span>"
    <span class=sf-dump-index>2</span> => "<span class=sf-dump-str title="2 characters">id</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">visible</span>: []
  #<span class=sf-dump-protected title="Protected property">fillable</span>: <span class=sf-dump-note>array:10</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str title="4 characters">name</span>"
    <span class=sf-dump-index>1</span> => "<span class=sf-dump-str title="3 characters">cui</span>"
    <span class=sf-dump-index>2</span> => "<span class=sf-dump-str title="7 characters">reg_com</span>"
    <span class=sf-dump-index>3</span> => "<span class=sf-dump-str title="4 characters">euid</span>"
    <span class=sf-dump-index>4</span> => "<span class=sf-dump-str title="6 characters">status</span>"
    <span class=sf-dump-index>5</span> => "<span class=sf-dump-str title="17 characters">registration_date</span>"
    <span class=sf-dump-index>6</span> => "<span class=sf-dump-str title="4 characters">type</span>"
    <span class=sf-dump-index>7</span> => "<span class=sf-dump-str title="7 characters">website</span>"
    <span class=sf-dump-index>8</span> => "<span class=sf-dump-str title="14 characters">parent_country</span>"
    <span class=sf-dump-index>9</span> => "<span class=sf-dump-str title="4 characters">mark</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">guarded</span>: <span class=sf-dump-note>array:1</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str>*</span>"
  </samp>]
</samp>}
</pre><script>Sfdump("sf-dump-1224189652", {"maxDepth":3,"maxStringLength":160})</script> 8.3.29 12.44.0 ro false true local a5562107215ff05a7fc40849695aea476b6008f5 Optimizare SEO: pagini individuale companii, meta taguri, harta siteului »ôi favicon v1.0 git@github.com:tudorr89/info-firme.git true   select * from `companies` where `cui` = ? limit 1 4.67 mysql 410272 1767511853.1373 select * from `addresses` where `addresses`.`company_id` in (3) 2.34 mysql  1767511853.143 select * from `infos` where `infos`.`company_id` in (3) 1.6 mysql  1767511853.1454 select * from `statuses` where `statuses`.`registration` in (?) 3.22 mysql J40/5712/1992 1767511853.1493 select * from `nomenclators` where `nomenclators`.`code` in (?) 1.52 mysql 1084 1767511853.1523 select * from `caen_companies` where `caen_companies`.`registration` in (?) 2.53 mysql J40/5712/1992 1767511853.1563 select * from `legal_representatives` where `legal_representatives`.`registration` in (?) 1.66 mysql J40/5712/1992 1767511853.1588 select * from `natural_person_representatives` where `natural_person_representatives`.`registration` in (?) 1.28 mysql J40/5712/1992 1767511853.1607 select * from `e_u_branches` where `e_u_branches`.`registration` in (?) 1.16 mysql J40/5712/1992 1767511853.1626 local null null /Users/tudor/Projects/info-firme null 86b4fc4d-55b5-473b-a1bc-e836efd51c36 null null phpstorm auto false /Users/tudor/Projects/info-firme null true false / Clipboard %path:%line true Sublime subl://open?url=file://%path&line=%line TextMate txmt://open?url=file://%path&line=%line Emacs emacs://open?url=file://%path&line=%line MacVim mvim://open/?url=file://%path&line=%line PhpStorm phpstorm://open?file=%path&line=%line PHPStorm Remote javascript:r = new XMLHttpRequest;r.open("get", "http://localhost:63342/api/file/%path:%line");r.send() Idea idea://open?file=%path&line=%line VS Code vscode://file/%path:%line VS Code Insiders vscode-insiders://file/%path:%line VS Code Remote vscode://vscode-remote/%path:%line VS Code Insiders Remote vscode-insiders://vscode-remote/%path:%line VS Codium vscodium://file/%path:%line Cursor cursor://file/%path:%line Atom atom://core/open/file?filename=%path&line=%line Nova nova://open?path=%path&line=%line NetBeans netbeans://open/?f=%path:%line Xdebug xdebug://%path@%line https://flareapp.io/api/public-reports  /_ignition/update-config /Users/tudor/Projects/info-firme/resources/views/components/seo-meta.blade.php 94 require null "postalCode": "{{ $company->address->postalCode ?? '' }}", "addressCountry": "RO" } @endif @if($company->info && $company->info->phone) ,"telephone": "{{ $company->info->phone }}" @endif } </script> @else <!-- Schema.org for Website with Search Action --> <script type="application/ld+json"> { "@context": "https://schema.org", "@type": "WebSite", "name": "lista-firme.info", "url": "{{ url('/') }}", "description": "CƒÉutare »ôi descoperire de informa»õii despre companii rom√¢ne»ôti", "potentialAction": { "@type": "SearchAction", "target": { "@type": "EntryPoint", "urlTemplate": "{{ url('/') }}?search={search_term_string}" }, "query-input": "required name=search_term_string" } } </script> @endif null  true resources/views/components/seo-meta.blade.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php 123 Illuminate\Filesystem\{closure} Illuminate\Filesystem\Filesystem * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */ public function getRequire($path, array $data = []) { if ($this->isFile($path)) { $__path = $path; $__data = $data; null return (static function () use ($__path, $__data) { extract($__data, EXTR_SKIP); null return require $__path; })(); } null throw new FileNotFoundException("File does not exist at path {$path}."); } null /** * Require the given file once. * * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException arg0 /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false false vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php 124 getRequire Illuminate\Filesystem\Filesystem * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */ public function getRequire($path, array $data = []) { if ($this->isFile($path)) { $__path = $path; $__data = $data; null return (static function () use ($__path, $__data) { extract($__data, EXTR_SKIP); null return require $__path; })(); } null throw new FileNotFoundException("File does not exist at path {$path}."); } null /** * Require the given file once. * * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */  false vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Engines/PhpEngine.php 57 evaluatePath Illuminate\View\Engines\PhpEngine * * @param  string  $path * @param  array  $data * @return string */ protected function evaluatePath($path, $data) { $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or // an exception is thrown. This prevents any partial views from leaking. try { $this->files->getRequire($path, $data); } catch (Throwable $e) { $this->handleViewException($e, $obLevel); } null return ltrim(ob_get_clean()); } null /** * Handle a view exception. * * @param  \Throwable  $e * @param  int  $obLevel * @return void * path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false vendor/laravel/framework/src/Illuminate/View/Engines/PhpEngine.php /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php 22 evaluatePath Livewire\Mechanisms\ExtendBlade\ExtendedCompilerEngine class ExtendedCompilerEngine extends \Illuminate\View\Engines\CompilerEngine { public function get($path, array $data = []) { if (! ExtendBlade::isRenderingLivewireComponent()) return parent::get($path, $data); null $currentComponent = ExtendBlade::currentRendering(); null trigger('view:compile', $currentComponent, $path); null return parent::get($path, $data); } null protected function evaluatePath($__path, $__data) { if (! ExtendBlade::isRenderingLivewireComponent()) { return parent::evaluatePath($__path, $__data); } null $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or // an exception is thrown. This prevents any partial views from leaking. try { $component = ExtendBlade::currentRendering(); null \Closure::bind(function () use ($__path, $__data) { extract($__data, EXTR_SKIP); path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Engines/CompilerEngine.php 76 get Illuminate\View\Engines\CompilerEngine { $this->lastCompiled[] = $path; null // If this given view has expired, which means it has simply been edited since // it was last compiled, we will re-compile the views so we can evaluate a // fresh copy of the view. We'll pass the compiler the path of the view. if (! isset($this->compiledOrNotExpired[$path]) && $this->compiler->isExpired($path)) { $this->compiler->compile($path); } null // Once we have the path to the compiled file, we will evaluate the paths with // typical PHP just like any other templates. We also keep a stack of views // which have been rendered for right exception messages to be generated. null try { $results = $this->evaluatePath($this->compiler->getCompiledPath($path), $data); } catch (ViewException $e) { if (! Str::of($e->getMessage())->contains(['No such file or directory', 'File does not exist at path'])) { throw $e; } null if (! isset($this->compiledOrNotExpired[$path])) { throw $e; } null $this->compiler->compile($path); null $results = $this->evaluatePath($this->compiler->getCompiledPath($path), $data); } null __path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false __data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false vendor/laravel/framework/src/Illuminate/View/Engines/CompilerEngine.php /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php 10 get Livewire\Mechanisms\ExtendBlade\ExtendedCompilerEngine <?php null namespace Livewire\Mechanisms\ExtendBlade; null use function Livewire\trigger; null class ExtendedCompilerEngine extends \Illuminate\View\Engines\CompilerEngine { public function get($path, array $data = []) { if (! ExtendBlade::isRenderingLivewireComponent()) return parent::get($path, $data); null $currentComponent = ExtendBlade::currentRendering(); null trigger('view:compile', $currentComponent, $path); null return parent::get($path, $data); } null protected function evaluatePath($__path, $__data) { if (! ExtendBlade::isRenderingLivewireComponent()) { return parent::evaluatePath($__path, $__data); } null $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/ViewEngineDecorator.php 47 get Sentry\Laravel\Tracing\ViewEngineDecorator null // If there is no sampled span there is no need to wrap the engine call if ($parentSpan === null || !$parentSpan->getSampled()) { return $this->engine->get($path, $data); } null $span = $parentSpan->startChild( SpanContext::make() ->setOp('view.render') ->setOrigin('auto.view') ->setDescription($this->viewFactory->shared(self::SHARED_KEY, basename($path))) ); null SentrySdk::getCurrentHub()->setSpan($span); null $result = $this->engine->get($path, $data); null $span->finish(); null SentrySdk::getCurrentHub()->setSpan($parentSpan); null return $result; } null public function __call($name, $arguments) { return $this->engine->{$name}(...$arguments); } } null path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/ViewEngineDecorator.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 208 getContents Illuminate\View\View // Once we've finished rendering the view, we'll decrement the render count // so that each section gets flushed out next time a view is created and // no old sections are staying around in the memory of an environment. $this->factory->decrementRender(); null return $contents; } null /** * Get the evaluated contents of the view. * * @return string */ protected function getContents() { return $this->engine->get($this->path, $this->gatherData()); } null /** * Get the data bound to the view instance. * * @return array */ public function gatherData() { $data = array_merge($this->factory->getShared(), $this->data); null foreach ($data as $key => $value) { if ($value instanceof Renderable) { $data[$key] = $value->render(); path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false vendor/laravel/framework/src/Illuminate/View/View.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 191 renderContents Illuminate\View\View null /** * Get the contents of the view instance. * * @return string */ protected function renderContents() { // We will keep track of the number of views being rendered so we can flush // the section after the complete rendering operation is done. This will // clear out the sections for any separate views that may be rendered. $this->factory->incrementRender(); null $this->factory->callComposer($this); null $contents = $this->getContents(); null // Once we've finished rendering the view, we'll decrement the render count // so that each section gets flushed out next time a view is created and // no old sections are staying around in the memory of an environment. $this->factory->decrementRender(); null return $contents; } null /** * Get the evaluated contents of the view. * * @return string */  false vendor/laravel/framework/src/Illuminate/View/View.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 160 render Illuminate\View\View { return (new Collection($this->render(fn () => $this->factory->getFragments())))->implode(''); } null /** * Get the string contents of the view. * * @param  callable|null  $callback * @return string * * @throws \Throwable */ public function render(?callable $callback = null) { try { $contents = $this->renderContents(); null $response = isset($callback) ? $callback($this, $contents) : null; null // Once we have the contents of the view, we will flush the sections if we are // done rendering all views so that there is nothing left hanging over when // another view gets rendered in the future by the application developer. $this->factory->flushStateIfDoneRendering(); null return ! is_null($response) ? $response : $contents; } catch (Throwable $e) { $this->factory->flushState(); null throw $e; }  false vendor/laravel/framework/src/Illuminate/View/View.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Response.php 78 setContent Illuminate\Http\Response // from routes that will be automatically transformed to their JSON form. if ($this->shouldBeJson($content)) { $this->header('Content-Type', 'application/json'); null $content = $this->morphToJson($content); null if ($content === false) { throw new InvalidArgumentException(json_last_error_msg()); } } null // If this content implements the "Renderable" interface then we will call the // render method on the object so we will avoid any "__toString" exceptions // that might be thrown and have their errors obscured by PHP's handling. elseif ($content instanceof Renderable) { $content = $content->render(); } null parent::setContent($content); null return $this; } null /** * Determine if the given content should be turned into JSON. * * @param  mixed  $content * @return bool */ protected function shouldBeJson($content) callback null null false false false false vendor/laravel/framework/src/Illuminate/Http/Response.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Response.php 34 __construct Illuminate\Http\Response } null /** * Create a new HTTP response. * * @param  mixed  $content * @param  int  $status * @param  array  $headers * * @throws \InvalidArgumentException */ public function __construct($content = '', $status = 200, array $headers = []) { $this->headers = new ResponseHeaderBag($headers); null $this->setContent($content); $this->setStatusCode($status); $this->setProtocolVersion('1.0'); } null /** * Get the response content. */ #[\Override] public function getContent(): string|false { return transform(parent::getContent(), fn ($content) => $content, ''); } null /** null false vendor/laravel/framework/src/Illuminate/Http/Response.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 939 toResponse Illuminate\Routing\Router if ($response instanceof PsrResponseInterface) { $response = (new HttpFoundationFactory)->createResponse($response); } elseif ($response instanceof Model && $response->wasRecentlyCreated) { $response = new JsonResponse($response, 201); } elseif ($response instanceof Stringable) { $response = new Response($response->__toString(), 200, ['Content-Type' => 'text/html']); } elseif (! $response instanceof SymfonyResponse && ($response instanceof Arrayable || $response instanceof Jsonable || $response instanceof ArrayObject || $response instanceof JsonSerializable || $response instanceof stdClass || is_array($response))) { $response = new JsonResponse($response); } elseif (! $response instanceof SymfonyResponse) { $response = new Response($response, 200, ['Content-Type' => 'text/html']); } null if ($response->getStatusCode() === Response::HTTP_NOT_MODIFIED) { $response->setNotModified(); } null return $response->prepare($request); } null /** * Substitute the route bindings onto the route. * * @param  \Illuminate\Routing\Route  $route * @return \Illuminate\Routing\Route null false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 906 prepareResponse Illuminate\Routing\Router { return (new SortedMiddleware($this->middlewarePriority, $middlewares))->all(); } null /** * Create a response instance from the given value. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @param  mixed  $response * @return \Symfony\Component\HttpFoundation\Response */ public function prepareResponse($request, $response) { $this->events->dispatch(new PreparingResponse($request, $response)); null return tap(static::toResponse($request, $response), function ($response) use ($request) { $this->events->dispatch(new ResponsePrepared($request, $response)); }); } null /** * Static version of prepareResponse. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @param  mixed  $response * @return \Symfony\Component\HttpFoundation\Response */ public static function toResponse($request, $response) { if ($response instanceof Responsable) { null false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 821 Illuminate\Routing\{closure} Illuminate\Routing\Router * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; null $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddleware($route); null return (new Pipeline($this->container)) ->send($request) ->through($middleware) ->then(fn ($request) => $this->prepareResponse( $request, $route->run() )); } null /** * Gather the middleware for the given route with resolved class names. * * @param  \Illuminate\Routing\Route  $route * @return array */ public function gatherRouteMiddleware(Route $route) { return $this->resolveMiddleware($route->gatherMiddleware(), $route->excludedMiddleware()); } null false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 180 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline $this->finally = $callback; null return $this; } null /** * Get the final piece of the Closure onion. * * @param  \Closure  $destination * @return \Closure */ protected function prepareDestination(Closure $destination) { return function ($passable) use ($destination) { try { return $destination($passable); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; } null /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() { return function ($stack, $pipe) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/boost/src/Middleware/InjectBoost.php 22 handle Laravel\Boost\Middleware\InjectBoost use Closure; use Illuminate\Http\JsonResponse; use Illuminate\Http\RedirectResponse; use Illuminate\Http\Request; use Illuminate\View\View; use Laravel\Boost\Services\BrowserLogger; use Symfony\Component\HttpFoundation\BinaryFileResponse; use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpFoundation\StreamedResponse; null class InjectBoost { public function handle(Request $request, Closure $next): Response { /** @var Response $response */ $response = $next($request); null if ($this->shouldInject($response)) { $originalView = $response->original ?? null; $injectedContent = $this->injectScript($response->getContent()); $response->setContent($injectedContent); null if ($originalView instanceof View && property_exists($response, 'original')) { $response->original = $originalView; } } null return $response; } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/boost/src/Middleware/InjectBoost.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:178-184 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Middleware/SubstituteBindings.php 50 handle Illuminate\Routing\Middleware\SubstituteBindings { $this->router = $router; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $route = $request->route(); null try { $this->router->substituteBindings($route); $this->router->substituteImplicitBindings($route); } catch (ModelNotFoundException $exception) { if ($route->getMissing()) { return $route->getMissing()($request, $exception); } null throw $exception; } null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Routing/Middleware/SubstituteBindings.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/VerifyCsrfToken.php 87 handle Illuminate\Foundation\Http\Middleware\VerifyCsrfToken * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Illuminate\Session\TokenMismatchException */ public function handle($request, Closure $next) { if ( $this->isReading($request) || $this->runningUnitTests() || $this->inExceptArray($request) || $this->tokensMatch($request) ) { return tap($next($request), function ($response) use ($request) { if ($this->shouldAddXsrfTokenCookie()) { $this->addCookieToResponse($request, $response); } }); } null throw new TokenMismatchException('CSRF token mismatch.'); } null /** * Determine if the HTTP request uses a ‚Äòread‚Äô verb. * * @param  \Illuminate\Http\Request  $request * @return bool arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/VerifyCsrfToken.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Middleware/ShareErrorsFromSession.php 48 handle Illuminate\View\Middleware\ShareErrorsFromSession */ public function __construct(ViewFactory $view) { $this->view = $view; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { // If the current session has an "errors" variable bound to it, we will share // its value with all view instances so the views can easily access errors // without having to bind. An empty bag is set when there aren't errors. $this->view->share( 'errors', $request->session()->get('errors') ?: new ViewErrorBag ); null // Putting the errors in the view for every view allows the developer to just // assume that some errors are always available, which is convenient since // they don't have to continually run checks for the presence of errors. null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/View/Middleware/ShareErrorsFromSession.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php 120 handleStatefulRequest Illuminate\Session\Middleware\StartSession * @param  \Illuminate\Contracts\Session\Session  $session * @param  \Closure  $next * @return mixed */ protected function handleStatefulRequest(Request $request, $session, Closure $next) { // If a session driver has been configured, we will need to start the session here // so that the data is ready for an application. Note that the Laravel sessions // do not make use of PHP "native" sessions in any way since they are crappy. $request->setLaravelSession( $this->startSession($request, $session) ); null $this->collectGarbage($session); null $response = $next($request); null $this->storeCurrentUrl($request, $session); null $this->addCookieToResponse($response, $session); null // Again, if the session has been configured we will need to close out the session // so that the attributes may be persisted to some storage medium. We will also // add the session identifier cookie to the application response headers now. $this->saveSession($request); null return $response; } null /** arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php 63 handle Illuminate\Session\Middleware\StartSession * @return mixed */ public function handle($request, Closure $next) { if (! $this->sessionConfigured()) { return $next($request); } null $session = $this->getSession($request); null if ($this->manager->shouldBlock() || ($request->route() instanceof Route && $request->route()->locksFor())) { return $this->handleRequestWhileBlocking($request, $session, $next); } null return $this->handleStatefulRequest($request, $session, $next); } null /** * Handle the given request within session state. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Contracts\Session\Session  $session * @param  \Closure  $next * @return mixed */ protected function handleRequestWhileBlocking(Request $request, $session, Closure $next) { if (! $request->route() instanceof Route) { return; request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false session object Illuminate\Session\Store false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Cookie/Middleware/AddQueuedCookiesToResponse.php 36 handle Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse null /** * Create a new CookieQueue instance. * * @param  \Illuminate\Contracts\Cookie\QueueingFactory  $cookies */ public function __construct(CookieJar $cookies) { $this->cookies = $cookies; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); null foreach ($this->cookies->getQueuedCookies() as $cookie) { $response->headers->setCookie($cookie); } null return $response; } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Cookie/Middleware/AddQueuedCookiesToResponse.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Cookie/Middleware/EncryptCookies.php 74 handle Illuminate\Cookie\Middleware\EncryptCookies */ public function disableFor($name) { $this->except = array_merge($this->except, (array) $name); } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return \Symfony\Component\HttpFoundation\Response */ public function handle($request, Closure $next) { return $this->encrypt($next($this->decrypt($request))); } null /** * Decrypt the cookies on the request. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @return \Symfony\Component\HttpFoundation\Request */ protected function decrypt(Request $request) { foreach ($request->cookies as $key => $cookie) { if ($this->isDisabled($key)) { continue; } arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Cookie/Middleware/EncryptCookies.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 137 then Illuminate\Pipeline\Pipeline /** * Run the pipeline with a final destination callback. * * @param  \Closure  $destination * @return mixed */ public function then(Closure $destination) { $pipeline = array_reduce( array_reverse($this->pipes()), $this->carry(), $this->prepareDestination($destination) ); null try { return $this->withinTransaction !== false ? $this->getContainer()->make('db')->connection($this->withinTransaction)->transaction(fn () => $pipeline($this->passable)) : $pipeline($this->passable); } finally { if ($this->finally) { ($this->finally)($this->passable); } } } null /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 821 runRouteWithinStack Illuminate\Routing\Router * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; null $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddleware($route); null return (new Pipeline($this->container)) ->send($request) ->through($middleware) ->then(fn ($request) => $this->prepareResponse( $request, $route->run() )); } null /** * Gather the middleware for the given route with resolved class names. * * @param  \Illuminate\Routing\Route  $route * @return array */ public function gatherRouteMiddleware(Route $route) { return $this->resolveMiddleware($route->gatherMiddleware(), $route->excludedMiddleware()); } destination /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php:821-823 Closure false false false false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 800 runRoute Illuminate\Routing\Router null /** * Return the response for the given route. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Routing\Route  $route * @return \Symfony\Component\HttpFoundation\Response */ protected function runRoute(Request $request, Route $route) { $request->setRouteResolver(fn () => $route); null $this->events->dispatch(new RouteMatched($route, $request)); null return $this->prepareResponse($request, $this->runRouteWithinStack($route, $request) ); } null /** * Run the given route within a Stack "onion" instance. * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; route object Illuminate\Routing\Route false false false request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 764 dispatchToRoute Illuminate\Routing\Router public function dispatch(Request $request) { $this->currentRequest = $request; null return $this->dispatchToRoute($request); } null /** * Dispatch the request to a route and return the response. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatchToRoute(Request $request) { return $this->runRoute($request, $this->findRoute($request)); } null /** * Find the route matching a given request. * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Routing\Route */ protected function findRoute($request) { $this->events->dispatch(new Routing($request)); null $this->current = $route = $this->routes->match($request); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false route object Illuminate\Routing\Route false false false false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 753 dispatch Illuminate\Routing\Router $route = tap($this->routes->getByName($name))->bind($this->currentRequest); null return $this->runRoute($this->currentRequest, $route); } null /** * Dispatch the request to the application. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatch(Request $request) { $this->currentRequest = $request; null return $this->dispatchToRoute($request); } null /** * Dispatch the request to a route and return the response. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatchToRoute(Request $request) { return $this->runRoute($request, $this->findRoute($request)); } null /** request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 200 Illuminate\Foundation\Http\{closure} Illuminate\Foundation\Http\Kernel if (! $this->app->hasBeenBootstrapped()) { $this->app->bootstrapWith($this->bootstrappers()); } } null /** * Get the route dispatcher callback. * * @return \Closure */ protected function dispatchToRouter() { return function ($request) { $this->app->instance('request', $request); null return $this->router->dispatch($request); }; } null /** * Call the terminate method on any terminable middleware. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Http\Response  $response * @return void */ public function terminate($request, $response) { $this->app['events']->dispatch(new Terminating); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 180 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline $this->finally = $callback; null return $this; } null /** * Get the final piece of the Closure onion. * * @param  \Closure  $destination * @return \Closure */ protected function prepareDestination(Closure $destination) { return function ($passable) use ($destination) { try { return $destination($passable); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; } null /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() { return function ($stack, $pipe) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/FlushEventsMiddleware.php 13 handle Sentry\Laravel\Http\FlushEventsMiddleware <?php null namespace Sentry\Laravel\Http; null use Closure; use Illuminate\Http\Request; use Sentry\Laravel\Integration; null class FlushEventsMiddleware { public function handle(Request $request, Closure $next) { return $next($request); } null public function terminate(Request $request, $response): void { Integration::flushEvents(); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/FlushEventsMiddleware.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:178-184 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestIpMiddleware.php 45 handle Sentry\Laravel\Http\SetRequestIpMiddleware * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure                 $next * * @return mixed */ public function handle(Request $request, Closure $next) { $container = Container::getInstance(); null if ($container->bound(HubInterface::class)) { /** @var \Sentry\State\HubInterface $sentry */ $sentry = $container->make(HubInterface::class); null $client = $sentry->getClient(); null if ($client !== null && $client->getOptions()->shouldSendDefaultPii()) { $sentry->configureScope(static function (Scope $scope) use ($request): void { $scope->setUser([ 'ip_address' => $request->ip(), ]); }); } } null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestIpMiddleware.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestMiddleware.php 31 handle Sentry\Laravel\Http\SetRequestMiddleware */ class SetRequestMiddleware { public function handle(Request $request, Closure $next) { $container = Container::getInstance(); null if ($container->bound(HubInterface::class)) { $psrRequest = $this->resolvePsrRequest($container); null if ($psrRequest !== null) { $container->instance(LaravelRequestFetcher::CONTAINER_PSR7_INSTANCE_KEY, $psrRequest); } } null return $next($request); } null private function resolvePsrRequest(Container $container): ?ServerRequestInterface { try { return $container->make(ServerRequestInterface::class); } catch (Throwable $e) { // Do not crash if there is an exception thrown while resolving the request object } null return null; } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestMiddleware.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Features/SupportDisablingBackButtonCache/DisableBackButtonCacheMiddleware.php 19 handle Livewire\Features\SupportDisablingBackButtonCache\DisableBackButtonCacheMiddleware null use Closure; use Symfony\Component\HttpFoundation\Response; null class DisableBackButtonCacheMiddleware { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); null if ($response instanceof Response && SupportDisablingBackButtonCache::$disableBackButtonCache){ $response->headers->add([ 'Pragma' => 'no-cache', 'Expires' => 'Fri, 01 Jan 1990 00:00:00 GMT', 'Cache-Control' => 'no-cache, must-revalidate, no-store, max-age=0, private', ]); null // We do flush this in the `SupportDisablingBackButtonCache` hook, but we // need to do it here as well to ensure that unit tests still work... SupportDisablingBackButtonCache::$disableBackButtonCache = false; } null return $response; arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/livewire/livewire/src/Features/SupportDisablingBackButtonCache/DisableBackButtonCacheMiddleware.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php 21 handle Illuminate\Foundation\Http\Middleware\TransformsRequest use Symfony\Component\HttpFoundation\ParameterBag; null class TransformsRequest { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $this->clean($request); null return $next($request); } null /** * Clean the request's data. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function clean($request) { $this->cleanParameterBag($request->query); null if ($request->isJson()) { $this->cleanParameterBag($request->json()); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ConvertEmptyStringsToNull.php 31 handle Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { foreach (static::$skipCallbacks as $callback) { if ($callback($request)) { return $next($request); } } null return parent::handle($request, $next); } null /** * Transform the given value. * * @param  string  $key * @param  mixed  $value * @return mixed */ protected function transform($key, $value) { return $value === '' ? null : $value; } null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ConvertEmptyStringsToNull.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php 21 handle Illuminate\Foundation\Http\Middleware\TransformsRequest use Symfony\Component\HttpFoundation\ParameterBag; null class TransformsRequest { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $this->clean($request); null return $next($request); } null /** * Clean the request's data. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function clean($request) { $this->cleanParameterBag($request->query); null if ($request->isJson()) { $this->cleanParameterBag($request->json()); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TrimStrings.php 51 handle Illuminate\Foundation\Http\Middleware\TrimStrings /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { foreach (static::$skipCallbacks as $callback) { if ($callback($request)) { return $next($request); } } null return parent::handle($request, $next); } null /** * Transform the given value. * * @param  string  $key * @param  mixed  $value * @return mixed */ protected function transform($key, $value) { $except = array_merge($this->except, static::$neverTrim); null if ($this->shouldSkip($key, $except) || ! is_string($value)) { request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TrimStrings.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/ValidatePostSize.php 27 handle Illuminate\Http\Middleware\ValidatePostSize * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Illuminate\Http\Exceptions\PostTooLargeException */ public function handle($request, Closure $next) { $max = $this->getPostMaxSize(); null if ($max > 0 && $request->server('CONTENT_LENGTH') > $max) { throw new PostTooLargeException('The POST data is too large.'); } null return $next($request); } null /** * Determine the server 'post_max_size' as bytes. * * @return int */ protected function getPostMaxSize() { if (is_numeric($postMaxSize = ini_get('post_max_size'))) { return (int) $postMaxSize; } null $metric = strtoupper(substr($postMaxSize, -1)); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Http/Middleware/ValidatePostSize.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/PreventRequestsDuringMaintenance.php 109 handle Illuminate\Foundation\Http\Middleware\PreventRequestsDuringMaintenance return response( $data['template'], $data['status'] ?? 503, $this->getHeaders($data) ); } null throw new HttpException( $data['status'] ?? 503, 'Service Unavailable', null, $this->getHeaders($data) ); } null return $next($request); } null /** * Determine if the incoming request has a maintenance mode bypass cookie. * * @param  \Illuminate\Http\Request  $request * @param  array  $data * @return bool */ protected function hasValidBypassCookie($request, array $data) { return isset($data['secret']) && $request->cookie('laravel_maintenance') && MaintenanceModeBypassCookie::isValid( arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/PreventRequestsDuringMaintenance.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/HandleCors.php 48 handle Illuminate\Http\Middleware\HandleCors { $this->container = $container; $this->cors = $cors; } null /** * Handle the incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return \Illuminate\Http\Response */ public function handle($request, Closure $next) { if (! $this->hasMatchingPath($request)) { return $next($request); } null $this->cors->setOptions($this->container['config']->get('cors', [])); null if ($this->cors->isPreflightRequest($request)) { $response = $this->cors->handlePreflightRequest($request); null $this->cors->varyHeader($response, 'Access-Control-Request-Method'); null return $response; } null $response = $next($request); null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Http/Middleware/HandleCors.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/TrustProxies.php 58 handle Illuminate\Http\Middleware\TrustProxies /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Symfony\Component\HttpKernel\Exception\HttpException */ public function handle(Request $request, Closure $next) { $request::setTrustedProxies([], $this->getTrustedHeaderNames()); null $this->setTrustedProxyIpAddresses($request); null return $next($request); } null /** * Sets the trusted proxies on the request. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function setTrustedProxyIpAddresses(Request $request) { $trustedIps = $this->proxies() ?: config('trustedproxy.proxies'); null if (is_null($trustedIps) && (laravel_cloud() || arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Http/Middleware/TrustProxies.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/Middleware.php 79 handle Sentry\Laravel\Tracing\Middleware null /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * * @return mixed */ public function handle(Request $request, Closure $next) { if (app()->bound(HubInterface::class)) { $this->startTransaction($request); } null return $next($request); } null /** * Handle the application termination. * * @param \Illuminate\Http\Request $request * @param mixed $response * * @return void */ public function terminate(Request $request, $response): void { // If there is no transaction there is nothing for us to do if ($this->transaction === null) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/Middleware.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 137 then Illuminate\Pipeline\Pipeline /** * Run the pipeline with a final destination callback. * * @param  \Closure  $destination * @return mixed */ public function then(Closure $destination) { $pipeline = array_reduce( array_reverse($this->pipes()), $this->carry(), $this->prepareDestination($destination) ); null try { return $this->withinTransaction !== false ? $this->getContainer()->make('db')->connection($this->withinTransaction)->transaction(fn () => $pipeline($this->passable)) : $pipeline($this->passable); } finally { if ($this->finally) { ($this->finally)($this->passable); } } } null /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 175 sendRequestThroughRouter Illuminate\Foundation\Http\Kernel * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Http\Response */ protected function sendRequestThroughRouter($request) { $this->app->instance('request', $request); null Request::clearResolvedInstance(); null $this->bootstrap(); null return (new Pipeline($this->app)) ->send($request) ->through($this->app->shouldSkipMiddleware() ? [] : $this->middleware) ->then($this->dispatchToRouter()); } null /** * Bootstrap the application for HTTP requests. * * @return void */ public function bootstrap() { if (! $this->app->hasBeenBootstrapped()) { $this->app->bootstrapWith($this->bootstrappers()); } } null destination /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php:197-201 Closure false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 144 handle Illuminate\Foundation\Http\Kernel } null /** * Handle an incoming HTTP request. * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Http\Response */ public function handle($request) { $this->requestStartedAt = Carbon::now(); null try { $request->enableHttpMethodParameterOverride(); null $response = $this->sendRequestThroughRouter($request); } catch (Throwable $e) { $this->reportException($e); null $response = $this->renderException($request, $e); } null $this->app['events']->dispatch( new RequestHandled($request, $response) ); null return $response; } null /** request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php /Users/tudor/Projects/info-firme/public/index.php 51 require null | | Composer provides a convenient, automatically generated class loader for | this application. We just need to utilize it! We'll simply require it | into the script here so we don't need to manually load our classes. | */ null require __DIR__.'/../vendor/autoload.php'; null /* |-------------------------------------------------------------------------- | Run The Application |-------------------------------------------------------------------------- | | Once we have the application, we can handle the incoming request using | the application's HTTP kernel. Then, we will send the response back | to this client's browser, allowing them to enjoy our application. | */ null $app = require_once __DIR__.'/../bootstrap/app.php'; null $kernel = $app->make(Kernel::class); null $response = $kernel->handle( $request = Request::capture() )->send(); null $kernel->terminate($request, $response); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false true public/index.php /Users/tudor/.composer/vendor/laravel/valet/server.php 110 [top] null $isPhpFile = pathinfo($uri, PATHINFO_EXTENSION) === 'php'; null if ($uri !== '/' && ! $isPhpFile && $staticFilePath = $valetDriver->isStaticFile($valetSitePath, $siteName, $uri)) { return $valetDriver->serveStaticFile($staticFilePath, $valetSitePath, $siteName, $uri); } null /** * Allow for drivers to take pre-loading actions (e.g. setting server variables). */ $valetDriver->beforeLoading($valetSitePath, $siteName, $uri); null /** * Attempt to dispatch to a front controller. */ $frontControllerPath = $valetDriver->frontControllerPath( $valetSitePath, $siteName, $uri ); null if (! $frontControllerPath) { if (isset($valetConfig['directory-listing']) && $valetConfig['directory-listing'] == 'on') { Server::showDirectoryListing($valetSitePath, $uri); } null Server::show404(); } null chdir(dirname($frontControllerPath)); null require $frontControllerPath; null  true /Users/tudor/.composer/vendor/laravel/valet/server.php https://info-firme.test/companie/410272 null GET Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36    select * from `companies` where `cui` = ? limit 1 4.67 mysql 410272 1767511853.1373 select * from `addresses` where `addresses`.`company_id` in (3) 2.34 mysql  1767511853.143 select * from `infos` where `infos`.`company_id` in (3) 1.6 mysql  1767511853.1454 select * from `statuses` where `statuses`.`registration` in (?) 3.22 mysql J40/5712/1992 1767511853.1493 select * from `nomenclators` where `nomenclators`.`code` in (?) 1.52 mysql 1084 1767511853.1523 select * from `caen_companies` where `caen_companies`.`registration` in (?) 2.53 mysql J40/5712/1992 1767511853.1563 select * from `legal_representatives` where `legal_representatives`.`registration` in (?) 1.66 mysql J40/5712/1992 1767511853.1588 select * from `natural_person_representatives` where `natural_person_representatives`.`registration` in (?) 1.28 mysql J40/5712/1992 1767511853.1607 select * from `e_u_branches` where `e_u_branches`.`registration` in (?) 1.16 mysql J40/5712/1992 1767511853.1626   null info-firme.test <CENSORED> u=0, i en-US,en;q=0.9 gzip, deflate, br, zstd document ?1 navigate none text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36 1 "macOS" ?0 "Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24" uAXsyM05tx1x32aTeC4WkDxaO0P7k8tYKjJmZ84J vM3se5WQ0HWW2xKJndqeDDnC0KAHLR7OtAe15Hss uAXsyM05tx1x32aTeC4WkDxaO0P7k8tYKjJmZ84J https://info-firme.test/sitemap-1.xml null   8.3.29 12.44.0 ro false true local null company.show 410272 App\Http\Controllers\CompanyController@show web a5562107215ff05a7fc40849695aea476b6008f5 Optimizare SEO: pagini individuale companii, meta taguri, harta siteului »ôi favicon v1.0 git@github.com:tudorr89/info-firme.git true null /Users/tudor/Projects/info-firme/resources/views/components/seo-meta.blade.php <pre class=sf-dump id=sf-dump-1862492123 data-indent-pad="  "><span class=sf-dump-note>Illuminate\Support\ViewErrorBag</span> {<a class=sf-dump-ref>#1342</a><samp data-depth=1 class=sf-dump-expanded>
  #<span class=sf-dump-protected title="Protected property">bags</span>: []
</samp>}
</pre><script>Sfdump("sf-dump-1862492123", {"maxDepth":3,"maxStringLength":160})</script> <pre class=sf-dump id=sf-dump-1064693183 data-indent-pad="  ">"<span class=sf-dump-str title="14 characters">companies.show</span>"
</pre><script>Sfdump("sf-dump-1064693183", {"maxDepth":3,"maxStringLength":160})</script> <pre class=sf-dump id=sf-dump-1224189652 data-indent-pad="  "><span class=sf-dump-note>App\Models\Company</span> {<a class=sf-dump-ref>#982</a><samp data-depth=1 class=sf-dump-expanded>
  #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
  #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="9 characters">companies</span>"
  #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
  #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
  +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
  #<span class=sf-dump-protected title="Protected property">with</span>: []
  #<span class=sf-dump-protected title="Protected property">withCount</span>: []
  +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
  +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
  +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:12</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>id</span>" => <span class=sf-dump-num>3</span>
    "<span class=sf-dump-key>name</span>" => "<span class=sf-dump-str title="23 characters">COLIU IMPORT EXPORT SRL</span>"
    "<span class=sf-dump-key>cui</span>" => "<span class=sf-dump-str title="6 characters">410272</span>"
    "<span class=sf-dump-key>euid</span>" => "<span class=sf-dump-str title="20 characters">ROONRC.J40/5712/1992</span>"
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="19 characters">1992-03-11 17:31:22</span>"
    "<span class=sf-dump-key>type</span>" => "<span class=sf-dump-str title="3 characters">SRL</span>"
    "<span class=sf-dump-key>website</span>" => ""
    "<span class=sf-dump-key>parent_country</span>" => ""
    "<span class=sf-dump-key>mark</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>reg_com</span>" => "<span class=sf-dump-str title="13 characters">J40/5712/1992</span>"
    "<span class=sf-dump-key>created_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
    "<span class=sf-dump-key>updated_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:12</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>id</span>" => <span class=sf-dump-num>3</span>
    "<span class=sf-dump-key>name</span>" => "<span class=sf-dump-str title="23 characters">COLIU IMPORT EXPORT SRL</span>"
    "<span class=sf-dump-key>cui</span>" => "<span class=sf-dump-str title="6 characters">410272</span>"
    "<span class=sf-dump-key>euid</span>" => "<span class=sf-dump-str title="20 characters">ROONRC.J40/5712/1992</span>"
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="19 characters">1992-03-11 17:31:22</span>"
    "<span class=sf-dump-key>type</span>" => "<span class=sf-dump-str title="3 characters">SRL</span>"
    "<span class=sf-dump-key>website</span>" => ""
    "<span class=sf-dump-key>parent_country</span>" => ""
    "<span class=sf-dump-key>mark</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>reg_com</span>" => "<span class=sf-dump-str title="13 characters">J40/5712/1992</span>"
    "<span class=sf-dump-key>created_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
    "<span class=sf-dump-key>updated_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">changes</span>: []
  #<span class=sf-dump-protected title="Protected property">previous</span>: []
  #<span class=sf-dump-protected title="Protected property">casts</span>: <span class=sf-dump-note>array:1</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="4 characters">date</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
  #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
  #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
  #<span class=sf-dump-protected title="Protected property">appends</span>: []
  #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
  #<span class=sf-dump-protected title="Protected property">observables</span>: []
  #<span class=sf-dump-protected title="Protected property">relations</span>: <span class=sf-dump-note>array:7</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>address</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="App\Models\Address
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">App\Models</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Address</span></span> {<a class=sf-dump-ref>#2496</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
      #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="9 characters">addresses</span>"
      #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
      #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
      +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
      #<span class=sf-dump-protected title="Protected property">with</span>: []
      #<span class=sf-dump-protected title="Protected property">withCount</span>: []
      +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
      +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:16</span> [ &#8230;16]
      #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:16</span> [ &#8230;16]
      #<span class=sf-dump-protected title="Protected property">changes</span>: []
      #<span class=sf-dump-protected title="Protected property">previous</span>: []
      #<span class=sf-dump-protected title="Protected property">casts</span>: []
      #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">appends</span>: []
      #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
      #<span class=sf-dump-protected title="Protected property">observables</span>: []
      #<span class=sf-dump-protected title="Protected property">relations</span>: []
      #<span class=sf-dump-protected title="Protected property">touches</span>: []
      #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
      +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:4</span> [ &#8230;4]
      #<span class=sf-dump-protected title="Protected property">visible</span>: []
      #<span class=sf-dump-protected title="Protected property">fillable</span>: []
      #<span class=sf-dump-protected title="Protected property">guarded</span>: []
    </samp>}
    "<span class=sf-dump-key>info</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>status</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="App\Models\Status
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">App\Models</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Status</span></span> {<a class=sf-dump-ref>#2504</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
      #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="8 characters">statuses</span>"
      #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
      #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
      +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
      #<span class=sf-dump-protected title="Protected property">with</span>: []
      #<span class=sf-dump-protected title="Protected property">withCount</span>: []
      +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
      +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">changes</span>: []
      #<span class=sf-dump-protected title="Protected property">previous</span>: []
      #<span class=sf-dump-protected title="Protected property">casts</span>: []
      #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">appends</span>: []
      #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
      #<span class=sf-dump-protected title="Protected property">observables</span>: []
      #<span class=sf-dump-protected title="Protected property">relations</span>: <span class=sf-dump-note>array:1</span> [ &#8230;1]
      #<span class=sf-dump-protected title="Protected property">touches</span>: []
      #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
      +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">visible</span>: []
      #<span class=sf-dump-protected title="Protected property">fillable</span>: <span class=sf-dump-note>array:2</span> [ &#8230;2]
      #<span class=sf-dump-protected title="Protected property">guarded</span>: <span class=sf-dump-note>array:1</span> [ &#8230;1]
    </samp>}
    "<span class=sf-dump-key>caen</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#2499</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>legalRepresentatives</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#2545</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>naturalPersonRepresentatives</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#2552</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>euBranches</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#2559</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
  </samp>]
  #<span class=sf-dump-protected title="Protected property">touches</span>: []
  #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
  #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
  +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
  +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:3</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str title="10 characters">created_at</span>"
    <span class=sf-dump-index>1</span> => "<span class=sf-dump-str title="10 characters">updated_at</span>"
    <span class=sf-dump-index>2</span> => "<span class=sf-dump-str title="2 characters">id</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">visible</span>: []
  #<span class=sf-dump-protected title="Protected property">fillable</span>: <span class=sf-dump-note>array:10</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str title="4 characters">name</span>"
    <span class=sf-dump-index>1</span> => "<span class=sf-dump-str title="3 characters">cui</span>"
    <span class=sf-dump-index>2</span> => "<span class=sf-dump-str title="7 characters">reg_com</span>"
    <span class=sf-dump-index>3</span> => "<span class=sf-dump-str title="4 characters">euid</span>"
    <span class=sf-dump-index>4</span> => "<span class=sf-dump-str title="6 characters">status</span>"
    <span class=sf-dump-index>5</span> => "<span class=sf-dump-str title="17 characters">registration_date</span>"
    <span class=sf-dump-index>6</span> => "<span class=sf-dump-str title="4 characters">type</span>"
    <span class=sf-dump-index>7</span> => "<span class=sf-dump-str title="7 characters">website</span>"
    <span class=sf-dump-index>8</span> => "<span class=sf-dump-str title="14 characters">parent_country</span>"
    <span class=sf-dump-index>9</span> => "<span class=sf-dump-str title="4 characters">mark</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">guarded</span>: <span class=sf-dump-note>array:1</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str>*</span>"
  </samp>]
</samp>}
</pre><script>Sfdump("sf-dump-1224189652", {"maxDepth":3,"maxStringLength":160})</script> null null null  web https://info-firme.test/companie/410272 ParseError syntax error, unexpected end of file /Users/tudor/Projects/info-firme null 8.3.29 12.44.0 Flare local null require    {"url":"https://info-firme.test/companie/410272","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-04T07:30:53.690Z"} 
[2026-01-04 07:32:53] local.INFO: %cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools font-weight:bold {"url":"https://info-firme.test/companie/410272","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-04T07:32:53.218Z"} 
[2026-01-04 07:32:53] local.DEBUG: Laravel Client PHP 12.44.0 8.3.29 ParseError 1767511973 syntax error, unexpected end of file    /Users/tudor/Projects/info-firme/resources/views/components/seo-meta.blade.php 94 require null "postalCode": "{{ $company->address->postalCode ?? '' }}", "addressCountry": "RO" } @endif @if($company->info && $company->info->phone), ,"telephone": "{{ $company->info->phone }}" @endif } </script> @else <!-- Schema.org for Website with Search Action --> <script type="application/ld+json"> { "@context": "https://schema.org", "@type": "WebSite", "name": "lista-firme.info", "url": "{{ url('/') }}", "description": "CƒÉutare »ôi descoperire de informa»õii despre companii rom√¢ne»ôti", "potentialAction": { "@type": "SearchAction", "target": { "@type": "EntryPoint", "urlTemplate": "{{ url('/') }}?search={search_term_string}" }, "query-input": "required name=search_term_string" } } </script> @endif null  true /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php 123 Illuminate\Filesystem\{closure} Illuminate\Filesystem\Filesystem * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */ public function getRequire($path, array $data = []) { if ($this->isFile($path)) { $__path = $path; $__data = $data; null return (static function () use ($__path, $__data) { extract($__data, EXTR_SKIP); null return require $__path; })(); } null throw new FileNotFoundException("File does not exist at path {$path}."); } null /** * Require the given file once. * * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException arg0 /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php 124 getRequire Illuminate\Filesystem\Filesystem * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */ public function getRequire($path, array $data = []) { if ($this->isFile($path)) { $__path = $path; $__data = $data; null return (static function () use ($__path, $__data) { extract($__data, EXTR_SKIP); null return require $__path; })(); } null throw new FileNotFoundException("File does not exist at path {$path}."); } null /** * Require the given file once. * * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */  false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Engines/PhpEngine.php 57 evaluatePath Illuminate\View\Engines\PhpEngine * * @param  string  $path * @param  array  $data * @return string */ protected function evaluatePath($path, $data) { $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or // an exception is thrown. This prevents any partial views from leaking. try { $this->files->getRequire($path, $data); } catch (Throwable $e) { $this->handleViewException($e, $obLevel); } null return ltrim(ob_get_clean()); } null /** * Handle a view exception. * * @param  \Throwable  $e * @param  int  $obLevel * @return void * path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php 22 evaluatePath Livewire\Mechanisms\ExtendBlade\ExtendedCompilerEngine class ExtendedCompilerEngine extends \Illuminate\View\Engines\CompilerEngine { public function get($path, array $data = []) { if (! ExtendBlade::isRenderingLivewireComponent()) return parent::get($path, $data); null $currentComponent = ExtendBlade::currentRendering(); null trigger('view:compile', $currentComponent, $path); null return parent::get($path, $data); } null protected function evaluatePath($__path, $__data) { if (! ExtendBlade::isRenderingLivewireComponent()) { return parent::evaluatePath($__path, $__data); } null $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or // an exception is thrown. This prevents any partial views from leaking. try { $component = ExtendBlade::currentRendering(); null \Closure::bind(function () use ($__path, $__data) { extract($__data, EXTR_SKIP); path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Engines/CompilerEngine.php 76 get Illuminate\View\Engines\CompilerEngine { $this->lastCompiled[] = $path; null // If this given view has expired, which means it has simply been edited since // it was last compiled, we will re-compile the views so we can evaluate a // fresh copy of the view. We'll pass the compiler the path of the view. if (! isset($this->compiledOrNotExpired[$path]) && $this->compiler->isExpired($path)) { $this->compiler->compile($path); } null // Once we have the path to the compiled file, we will evaluate the paths with // typical PHP just like any other templates. We also keep a stack of views // which have been rendered for right exception messages to be generated. null try { $results = $this->evaluatePath($this->compiler->getCompiledPath($path), $data); } catch (ViewException $e) { if (! Str::of($e->getMessage())->contains(['No such file or directory', 'File does not exist at path'])) { throw $e; } null if (! isset($this->compiledOrNotExpired[$path])) { throw $e; } null $this->compiler->compile($path); null $results = $this->evaluatePath($this->compiler->getCompiledPath($path), $data); } null __path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false __data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php 10 get Livewire\Mechanisms\ExtendBlade\ExtendedCompilerEngine <?php null namespace Livewire\Mechanisms\ExtendBlade; null use function Livewire\trigger; null class ExtendedCompilerEngine extends \Illuminate\View\Engines\CompilerEngine { public function get($path, array $data = []) { if (! ExtendBlade::isRenderingLivewireComponent()) return parent::get($path, $data); null $currentComponent = ExtendBlade::currentRendering(); null trigger('view:compile', $currentComponent, $path); null return parent::get($path, $data); } null protected function evaluatePath($__path, $__data) { if (! ExtendBlade::isRenderingLivewireComponent()) { return parent::evaluatePath($__path, $__data); } null $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/ViewEngineDecorator.php 47 get Sentry\Laravel\Tracing\ViewEngineDecorator null // If there is no sampled span there is no need to wrap the engine call if ($parentSpan === null || !$parentSpan->getSampled()) { return $this->engine->get($path, $data); } null $span = $parentSpan->startChild( SpanContext::make() ->setOp('view.render') ->setOrigin('auto.view') ->setDescription($this->viewFactory->shared(self::SHARED_KEY, basename($path))) ); null SentrySdk::getCurrentHub()->setSpan($span); null $result = $this->engine->get($path, $data); null $span->finish(); null SentrySdk::getCurrentHub()->setSpan($parentSpan); null return $result; } null public function __call($name, $arguments) { return $this->engine->{$name}(...$arguments); } } null path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 208 getContents Illuminate\View\View // Once we've finished rendering the view, we'll decrement the render count // so that each section gets flushed out next time a view is created and // no old sections are staying around in the memory of an environment. $this->factory->decrementRender(); null return $contents; } null /** * Get the evaluated contents of the view. * * @return string */ protected function getContents() { return $this->engine->get($this->path, $this->gatherData()); } null /** * Get the data bound to the view instance. * * @return array */ public function gatherData() { $data = array_merge($this->factory->getShared(), $this->data); null foreach ($data as $key => $value) { if ($value instanceof Renderable) { $data[$key] = $value->render(); path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 191 renderContents Illuminate\View\View null /** * Get the contents of the view instance. * * @return string */ protected function renderContents() { // We will keep track of the number of views being rendered so we can flush // the section after the complete rendering operation is done. This will // clear out the sections for any separate views that may be rendered. $this->factory->incrementRender(); null $this->factory->callComposer($this); null $contents = $this->getContents(); null // Once we've finished rendering the view, we'll decrement the render count // so that each section gets flushed out next time a view is created and // no old sections are staying around in the memory of an environment. $this->factory->decrementRender(); null return $contents; } null /** * Get the evaluated contents of the view. * * @return string */  false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 160 render Illuminate\View\View { return (new Collection($this->render(fn () => $this->factory->getFragments())))->implode(''); } null /** * Get the string contents of the view. * * @param  callable|null  $callback * @return string * * @throws \Throwable */ public function render(?callable $callback = null) { try { $contents = $this->renderContents(); null $response = isset($callback) ? $callback($this, $contents) : null; null // Once we have the contents of the view, we will flush the sections if we are // done rendering all views so that there is nothing left hanging over when // another view gets rendered in the future by the application developer. $this->factory->flushStateIfDoneRendering(); null return ! is_null($response) ? $response : $contents; } catch (Throwable $e) { $this->factory->flushState(); null throw $e; }  false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Response.php 78 setContent Illuminate\Http\Response // from routes that will be automatically transformed to their JSON form. if ($this->shouldBeJson($content)) { $this->header('Content-Type', 'application/json'); null $content = $this->morphToJson($content); null if ($content === false) { throw new InvalidArgumentException(json_last_error_msg()); } } null // If this content implements the "Renderable" interface then we will call the // render method on the object so we will avoid any "__toString" exceptions // that might be thrown and have their errors obscured by PHP's handling. elseif ($content instanceof Renderable) { $content = $content->render(); } null parent::setContent($content); null return $this; } null /** * Determine if the given content should be turned into JSON. * * @param  mixed  $content * @return bool */ protected function shouldBeJson($content) callback null null false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Response.php 34 __construct Illuminate\Http\Response } null /** * Create a new HTTP response. * * @param  mixed  $content * @param  int  $status * @param  array  $headers * * @throws \InvalidArgumentException */ public function __construct($content = '', $status = 200, array $headers = []) { $this->headers = new ResponseHeaderBag($headers); null $this->setContent($content); $this->setStatusCode($status); $this->setProtocolVersion('1.0'); } null /** * Get the response content. */ #[\Override] public function getContent(): string|false { return transform(parent::getContent(), fn ($content) => $content, ''); } null /** null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 939 toResponse Illuminate\Routing\Router if ($response instanceof PsrResponseInterface) { $response = (new HttpFoundationFactory)->createResponse($response); } elseif ($response instanceof Model && $response->wasRecentlyCreated) { $response = new JsonResponse($response, 201); } elseif ($response instanceof Stringable) { $response = new Response($response->__toString(), 200, ['Content-Type' => 'text/html']); } elseif (! $response instanceof SymfonyResponse && ($response instanceof Arrayable || $response instanceof Jsonable || $response instanceof ArrayObject || $response instanceof JsonSerializable || $response instanceof stdClass || is_array($response))) { $response = new JsonResponse($response); } elseif (! $response instanceof SymfonyResponse) { $response = new Response($response, 200, ['Content-Type' => 'text/html']); } null if ($response->getStatusCode() === Response::HTTP_NOT_MODIFIED) { $response->setNotModified(); } null return $response->prepare($request); } null /** * Substitute the route bindings onto the route. * * @param  \Illuminate\Routing\Route  $route * @return \Illuminate\Routing\Route null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 906 prepareResponse Illuminate\Routing\Router { return (new SortedMiddleware($this->middlewarePriority, $middlewares))->all(); } null /** * Create a response instance from the given value. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @param  mixed  $response * @return \Symfony\Component\HttpFoundation\Response */ public function prepareResponse($request, $response) { $this->events->dispatch(new PreparingResponse($request, $response)); null return tap(static::toResponse($request, $response), function ($response) use ($request) { $this->events->dispatch(new ResponsePrepared($request, $response)); }); } null /** * Static version of prepareResponse. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @param  mixed  $response * @return \Symfony\Component\HttpFoundation\Response */ public static function toResponse($request, $response) { if ($response instanceof Responsable) { null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 821 Illuminate\Routing\{closure} Illuminate\Routing\Router * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; null $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddleware($route); null return (new Pipeline($this->container)) ->send($request) ->through($middleware) ->then(fn ($request) => $this->prepareResponse( $request, $route->run() )); } null /** * Gather the middleware for the given route with resolved class names. * * @param  \Illuminate\Routing\Route  $route * @return array */ public function gatherRouteMiddleware(Route $route) { return $this->resolveMiddleware($route->gatherMiddleware(), $route->excludedMiddleware()); } null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 180 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline $this->finally = $callback; null return $this; } null /** * Get the final piece of the Closure onion. * * @param  \Closure  $destination * @return \Closure */ protected function prepareDestination(Closure $destination) { return function ($passable) use ($destination) { try { return $destination($passable); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; } null /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() { return function ($stack, $pipe) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/boost/src/Middleware/InjectBoost.php 22 handle Laravel\Boost\Middleware\InjectBoost use Closure; use Illuminate\Http\JsonResponse; use Illuminate\Http\RedirectResponse; use Illuminate\Http\Request; use Illuminate\View\View; use Laravel\Boost\Services\BrowserLogger; use Symfony\Component\HttpFoundation\BinaryFileResponse; use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpFoundation\StreamedResponse; null class InjectBoost { public function handle(Request $request, Closure $next): Response { /** @var Response $response */ $response = $next($request); null if ($this->shouldInject($response)) { $originalView = $response->original ?? null; $injectedContent = $this->injectScript($response->getContent()); $response->setContent($injectedContent); null if ($originalView instanceof View && property_exists($response, 'original')) { $response->original = $originalView; } } null return $response; } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:178-184 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Middleware/SubstituteBindings.php 50 handle Illuminate\Routing\Middleware\SubstituteBindings { $this->router = $router; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $route = $request->route(); null try { $this->router->substituteBindings($route); $this->router->substituteImplicitBindings($route); } catch (ModelNotFoundException $exception) { if ($route->getMissing()) { return $route->getMissing()($request, $exception); } null throw $exception; } null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/VerifyCsrfToken.php 87 handle Illuminate\Foundation\Http\Middleware\VerifyCsrfToken * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Illuminate\Session\TokenMismatchException */ public function handle($request, Closure $next) { if ( $this->isReading($request) || $this->runningUnitTests() || $this->inExceptArray($request) || $this->tokensMatch($request) ) { return tap($next($request), function ($response) use ($request) { if ($this->shouldAddXsrfTokenCookie()) { $this->addCookieToResponse($request, $response); } }); } null throw new TokenMismatchException('CSRF token mismatch.'); } null /** * Determine if the HTTP request uses a ‚Äòread‚Äô verb. * * @param  \Illuminate\Http\Request  $request * @return bool arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Middleware/ShareErrorsFromSession.php 48 handle Illuminate\View\Middleware\ShareErrorsFromSession */ public function __construct(ViewFactory $view) { $this->view = $view; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { // If the current session has an "errors" variable bound to it, we will share // its value with all view instances so the views can easily access errors // without having to bind. An empty bag is set when there aren't errors. $this->view->share( 'errors', $request->session()->get('errors') ?: new ViewErrorBag ); null // Putting the errors in the view for every view allows the developer to just // assume that some errors are always available, which is convenient since // they don't have to continually run checks for the presence of errors. null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php 120 handleStatefulRequest Illuminate\Session\Middleware\StartSession * @param  \Illuminate\Contracts\Session\Session  $session * @param  \Closure  $next * @return mixed */ protected function handleStatefulRequest(Request $request, $session, Closure $next) { // If a session driver has been configured, we will need to start the session here // so that the data is ready for an application. Note that the Laravel sessions // do not make use of PHP "native" sessions in any way since they are crappy. $request->setLaravelSession( $this->startSession($request, $session) ); null $this->collectGarbage($session); null $response = $next($request); null $this->storeCurrentUrl($request, $session); null $this->addCookieToResponse($response, $session); null // Again, if the session has been configured we will need to close out the session // so that the attributes may be persisted to some storage medium. We will also // add the session identifier cookie to the application response headers now. $this->saveSession($request); null return $response; } null /** arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php 63 handle Illuminate\Session\Middleware\StartSession * @return mixed */ public function handle($request, Closure $next) { if (! $this->sessionConfigured()) { return $next($request); } null $session = $this->getSession($request); null if ($this->manager->shouldBlock() || ($request->route() instanceof Route && $request->route()->locksFor())) { return $this->handleRequestWhileBlocking($request, $session, $next); } null return $this->handleStatefulRequest($request, $session, $next); } null /** * Handle the given request within session state. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Contracts\Session\Session  $session * @param  \Closure  $next * @return mixed */ protected function handleRequestWhileBlocking(Request $request, $session, Closure $next) { if (! $request->route() instanceof Route) { return; request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false session object Illuminate\Session\Store false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Cookie/Middleware/AddQueuedCookiesToResponse.php 36 handle Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse null /** * Create a new CookieQueue instance. * * @param  \Illuminate\Contracts\Cookie\QueueingFactory  $cookies */ public function __construct(CookieJar $cookies) { $this->cookies = $cookies; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); null foreach ($this->cookies->getQueuedCookies() as $cookie) { $response->headers->setCookie($cookie); } null return $response; } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Cookie/Middleware/EncryptCookies.php 74 handle Illuminate\Cookie\Middleware\EncryptCookies */ public function disableFor($name) { $this->except = array_merge($this->except, (array) $name); } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return \Symfony\Component\HttpFoundation\Response */ public function handle($request, Closure $next) { return $this->encrypt($next($this->decrypt($request))); } null /** * Decrypt the cookies on the request. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @return \Symfony\Component\HttpFoundation\Request */ protected function decrypt(Request $request) { foreach ($request->cookies as $key => $cookie) { if ($this->isDisabled($key)) { continue; } arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 137 then Illuminate\Pipeline\Pipeline /** * Run the pipeline with a final destination callback. * * @param  \Closure  $destination * @return mixed */ public function then(Closure $destination) { $pipeline = array_reduce( array_reverse($this->pipes()), $this->carry(), $this->prepareDestination($destination) ); null try { return $this->withinTransaction !== false ? $this->getContainer()->make('db')->connection($this->withinTransaction)->transaction(fn () => $pipeline($this->passable)) : $pipeline($this->passable); } finally { if ($this->finally) { ($this->finally)($this->passable); } } } null /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 821 runRouteWithinStack Illuminate\Routing\Router * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; null $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddleware($route); null return (new Pipeline($this->container)) ->send($request) ->through($middleware) ->then(fn ($request) => $this->prepareResponse( $request, $route->run() )); } null /** * Gather the middleware for the given route with resolved class names. * * @param  \Illuminate\Routing\Route  $route * @return array */ public function gatherRouteMiddleware(Route $route) { return $this->resolveMiddleware($route->gatherMiddleware(), $route->excludedMiddleware()); } destination /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php:821-823 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 800 runRoute Illuminate\Routing\Router null /** * Return the response for the given route. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Routing\Route  $route * @return \Symfony\Component\HttpFoundation\Response */ protected function runRoute(Request $request, Route $route) { $request->setRouteResolver(fn () => $route); null $this->events->dispatch(new RouteMatched($route, $request)); null return $this->prepareResponse($request, $this->runRouteWithinStack($route, $request) ); } null /** * Run the given route within a Stack "onion" instance. * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; route object Illuminate\Routing\Route false false false request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 764 dispatchToRoute Illuminate\Routing\Router public function dispatch(Request $request) { $this->currentRequest = $request; null return $this->dispatchToRoute($request); } null /** * Dispatch the request to a route and return the response. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatchToRoute(Request $request) { return $this->runRoute($request, $this->findRoute($request)); } null /** * Find the route matching a given request. * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Routing\Route */ protected function findRoute($request) { $this->events->dispatch(new Routing($request)); null $this->current = $route = $this->routes->match($request); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false route object Illuminate\Routing\Route false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 753 dispatch Illuminate\Routing\Router $route = tap($this->routes->getByName($name))->bind($this->currentRequest); null return $this->runRoute($this->currentRequest, $route); } null /** * Dispatch the request to the application. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatch(Request $request) { $this->currentRequest = $request; null return $this->dispatchToRoute($request); } null /** * Dispatch the request to a route and return the response. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatchToRoute(Request $request) { return $this->runRoute($request, $this->findRoute($request)); } null /** request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 200 Illuminate\Foundation\Http\{closure} Illuminate\Foundation\Http\Kernel if (! $this->app->hasBeenBootstrapped()) { $this->app->bootstrapWith($this->bootstrappers()); } } null /** * Get the route dispatcher callback. * * @return \Closure */ protected function dispatchToRouter() { return function ($request) { $this->app->instance('request', $request); null return $this->router->dispatch($request); }; } null /** * Call the terminate method on any terminable middleware. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Http\Response  $response * @return void */ public function terminate($request, $response) { $this->app['events']->dispatch(new Terminating); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 180 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline $this->finally = $callback; null return $this; } null /** * Get the final piece of the Closure onion. * * @param  \Closure  $destination * @return \Closure */ protected function prepareDestination(Closure $destination) { return function ($passable) use ($destination) { try { return $destination($passable); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; } null /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() { return function ($stack, $pipe) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/FlushEventsMiddleware.php 13 handle Sentry\Laravel\Http\FlushEventsMiddleware <?php null namespace Sentry\Laravel\Http; null use Closure; use Illuminate\Http\Request; use Sentry\Laravel\Integration; null class FlushEventsMiddleware { public function handle(Request $request, Closure $next) { return $next($request); } null public function terminate(Request $request, $response): void { Integration::flushEvents(); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:178-184 Closure false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestIpMiddleware.php 45 handle Sentry\Laravel\Http\SetRequestIpMiddleware * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure                 $next * * @return mixed */ public function handle(Request $request, Closure $next) { $container = Container::getInstance(); null if ($container->bound(HubInterface::class)) { /** @var \Sentry\State\HubInterface $sentry */ $sentry = $container->make(HubInterface::class); null $client = $sentry->getClient(); null if ($client !== null && $client->getOptions()->shouldSendDefaultPii()) { $sentry->configureScope(static function (Scope $scope) use ($request): void { $scope->setUser([ 'ip_address' => $request->ip(), ]); }); } } null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestMiddleware.php 31 handle Sentry\Laravel\Http\SetRequestMiddleware */ class SetRequestMiddleware { public function handle(Request $request, Closure $next) { $container = Container::getInstance(); null if ($container->bound(HubInterface::class)) { $psrRequest = $this->resolvePsrRequest($container); null if ($psrRequest !== null) { $container->instance(LaravelRequestFetcher::CONTAINER_PSR7_INSTANCE_KEY, $psrRequest); } } null return $next($request); } null private function resolvePsrRequest(Container $container): ?ServerRequestInterface { try { return $container->make(ServerRequestInterface::class); } catch (Throwable $e) { // Do not crash if there is an exception thrown while resolving the request object } null return null; } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Features/SupportDisablingBackButtonCache/DisableBackButtonCacheMiddleware.php 19 handle Livewire\Features\SupportDisablingBackButtonCache\DisableBackButtonCacheMiddleware null use Closure; use Symfony\Component\HttpFoundation\Response; null class DisableBackButtonCacheMiddleware { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); null if ($response instanceof Response && SupportDisablingBackButtonCache::$disableBackButtonCache){ $response->headers->add([ 'Pragma' => 'no-cache', 'Expires' => 'Fri, 01 Jan 1990 00:00:00 GMT', 'Cache-Control' => 'no-cache, must-revalidate, no-store, max-age=0, private', ]); null // We do flush this in the `SupportDisablingBackButtonCache` hook, but we // need to do it here as well to ensure that unit tests still work... SupportDisablingBackButtonCache::$disableBackButtonCache = false; } null return $response; arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php 21 handle Illuminate\Foundation\Http\Middleware\TransformsRequest use Symfony\Component\HttpFoundation\ParameterBag; null class TransformsRequest { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $this->clean($request); null return $next($request); } null /** * Clean the request's data. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function clean($request) { $this->cleanParameterBag($request->query); null if ($request->isJson()) { $this->cleanParameterBag($request->json()); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ConvertEmptyStringsToNull.php 31 handle Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { foreach (static::$skipCallbacks as $callback) { if ($callback($request)) { return $next($request); } } null return parent::handle($request, $next); } null /** * Transform the given value. * * @param  string  $key * @param  mixed  $value * @return mixed */ protected function transform($key, $value) { return $value === '' ? null : $value; } null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php 21 handle Illuminate\Foundation\Http\Middleware\TransformsRequest use Symfony\Component\HttpFoundation\ParameterBag; null class TransformsRequest { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $this->clean($request); null return $next($request); } null /** * Clean the request's data. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function clean($request) { $this->cleanParameterBag($request->query); null if ($request->isJson()) { $this->cleanParameterBag($request->json()); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TrimStrings.php 51 handle Illuminate\Foundation\Http\Middleware\TrimStrings /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { foreach (static::$skipCallbacks as $callback) { if ($callback($request)) { return $next($request); } } null return parent::handle($request, $next); } null /** * Transform the given value. * * @param  string  $key * @param  mixed  $value * @return mixed */ protected function transform($key, $value) { $except = array_merge($this->except, static::$neverTrim); null if ($this->shouldSkip($key, $except) || ! is_string($value)) { request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/ValidatePostSize.php 27 handle Illuminate\Http\Middleware\ValidatePostSize * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Illuminate\Http\Exceptions\PostTooLargeException */ public function handle($request, Closure $next) { $max = $this->getPostMaxSize(); null if ($max > 0 && $request->server('CONTENT_LENGTH') > $max) { throw new PostTooLargeException('The POST data is too large.'); } null return $next($request); } null /** * Determine the server 'post_max_size' as bytes. * * @return int */ protected function getPostMaxSize() { if (is_numeric($postMaxSize = ini_get('post_max_size'))) { return (int) $postMaxSize; } null $metric = strtoupper(substr($postMaxSize, -1)); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/PreventRequestsDuringMaintenance.php 109 handle Illuminate\Foundation\Http\Middleware\PreventRequestsDuringMaintenance return response( $data['template'], $data['status'] ?? 503, $this->getHeaders($data) ); } null throw new HttpException( $data['status'] ?? 503, 'Service Unavailable', null, $this->getHeaders($data) ); } null return $next($request); } null /** * Determine if the incoming request has a maintenance mode bypass cookie. * * @param  \Illuminate\Http\Request  $request * @param  array  $data * @return bool */ protected function hasValidBypassCookie($request, array $data) { return isset($data['secret']) && $request->cookie('laravel_maintenance') && MaintenanceModeBypassCookie::isValid( arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/HandleCors.php 48 handle Illuminate\Http\Middleware\HandleCors { $this->container = $container; $this->cors = $cors; } null /** * Handle the incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return \Illuminate\Http\Response */ public function handle($request, Closure $next) { if (! $this->hasMatchingPath($request)) { return $next($request); } null $this->cors->setOptions($this->container['config']->get('cors', [])); null if ($this->cors->isPreflightRequest($request)) { $response = $this->cors->handlePreflightRequest($request); null $this->cors->varyHeader($response, 'Access-Control-Request-Method'); null return $response; } null $response = $next($request); null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/TrustProxies.php 58 handle Illuminate\Http\Middleware\TrustProxies /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Symfony\Component\HttpKernel\Exception\HttpException */ public function handle(Request $request, Closure $next) { $request::setTrustedProxies([], $this->getTrustedHeaderNames()); null $this->setTrustedProxyIpAddresses($request); null return $next($request); } null /** * Sets the trusted proxies on the request. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function setTrustedProxyIpAddresses(Request $request) { $trustedIps = $this->proxies() ?: config('trustedproxy.proxies'); null if (is_null($trustedIps) && (laravel_cloud() || arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/Middleware.php 79 handle Sentry\Laravel\Tracing\Middleware null /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * * @return mixed */ public function handle(Request $request, Closure $next) { if (app()->bound(HubInterface::class)) { $this->startTransaction($request); } null return $next($request); } null /** * Handle the application termination. * * @param \Illuminate\Http\Request $request * @param mixed $response * * @return void */ public function terminate(Request $request, $response): void { // If there is no transaction there is nothing for us to do if ($this->transaction === null) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 137 then Illuminate\Pipeline\Pipeline /** * Run the pipeline with a final destination callback. * * @param  \Closure  $destination * @return mixed */ public function then(Closure $destination) { $pipeline = array_reduce( array_reverse($this->pipes()), $this->carry(), $this->prepareDestination($destination) ); null try { return $this->withinTransaction !== false ? $this->getContainer()->make('db')->connection($this->withinTransaction)->transaction(fn () => $pipeline($this->passable)) : $pipeline($this->passable); } finally { if ($this->finally) { ($this->finally)($this->passable); } } } null /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 175 sendRequestThroughRouter Illuminate\Foundation\Http\Kernel * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Http\Response */ protected function sendRequestThroughRouter($request) { $this->app->instance('request', $request); null Request::clearResolvedInstance(); null $this->bootstrap(); null return (new Pipeline($this->app)) ->send($request) ->through($this->app->shouldSkipMiddleware() ? [] : $this->middleware) ->then($this->dispatchToRouter()); } null /** * Bootstrap the application for HTTP requests. * * @return void */ public function bootstrap() { if (! $this->app->hasBeenBootstrapped()) { $this->app->bootstrapWith($this->bootstrappers()); } } null destination /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php:197-201 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 144 handle Illuminate\Foundation\Http\Kernel } null /** * Handle an incoming HTTP request. * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Http\Response */ public function handle($request) { $this->requestStartedAt = Carbon::now(); null try { $request->enableHttpMethodParameterOverride(); null $response = $this->sendRequestThroughRouter($request); } catch (Throwable $e) { $this->reportException($e); null $response = $this->renderException($request, $e); } null $this->app['events']->dispatch( new RequestHandled($request, $response) ); null return $response; } null /** request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/public/index.php 51 require null | | Composer provides a convenient, automatically generated class loader for | this application. We just need to utilize it! We'll simply require it | into the script here so we don't need to manually load our classes. | */ null require __DIR__.'/../vendor/autoload.php'; null /* |-------------------------------------------------------------------------- | Run The Application |-------------------------------------------------------------------------- | | Once we have the application, we can handle the incoming request using | the application's HTTP kernel. Then, we will send the response back | to this client's browser, allowing them to enjoy our application. | */ null $app = require_once __DIR__.'/../bootstrap/app.php'; null $kernel = $app->make(Kernel::class); null $response = $kernel->handle( $request = Request::capture() )->send(); null $kernel->terminate($request, $response); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false true /Users/tudor/.composer/vendor/laravel/valet/server.php 110 [top] null $isPhpFile = pathinfo($uri, PATHINFO_EXTENSION) === 'php'; null if ($uri !== '/' && ! $isPhpFile && $staticFilePath = $valetDriver->isStaticFile($valetSitePath, $siteName, $uri)) { return $valetDriver->serveStaticFile($staticFilePath, $valetSitePath, $siteName, $uri); } null /** * Allow for drivers to take pre-loading actions (e.g. setting server variables). */ $valetDriver->beforeLoading($valetSitePath, $siteName, $uri); null /** * Attempt to dispatch to a front controller. */ $frontControllerPath = $valetDriver->frontControllerPath( $valetSitePath, $siteName, $uri ); null if (! $frontControllerPath) { if (isset($valetConfig['directory-listing']) && $valetConfig['directory-listing'] == 'on') { Server::showDirectoryListing($valetSitePath, $uri); } null Server::show404(); } null chdir(dirname($frontControllerPath)); null require $frontControllerPath; null  true https://info-firme.test/companie/410272 null GET Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36    info-firme.test <CENSORED> u=0, i en-US,en;q=0.9 gzip, deflate, br, zstd document ?1 navigate none text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36 1 "macOS" ?0 "Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24" no-cache no-cache uAXsyM05tx1x32aTeC4WkDxaO0P7k8tYKjJmZ84J vM3se5WQ0HWW2xKJndqeDDnC0KAHLR7OtAe15Hss uAXsyM05tx1x32aTeC4WkDxaO0P7k8tYKjJmZ84J https://info-firme.test/companie/410272 company.show   company.show 410272 App\Http\Controllers\CompanyController@show web /Users/tudor/Projects/info-firme/resources/views/components/seo-meta.blade.php <pre class=sf-dump id=sf-dump-1342951549 data-indent-pad="  "><span class=sf-dump-note>Illuminate\Support\ViewErrorBag</span> {<a class=sf-dump-ref>#1342</a><samp data-depth=1 class=sf-dump-expanded>
  #<span class=sf-dump-protected title="Protected property">bags</span>: []
</samp>}
</pre><script>Sfdump("sf-dump-1342951549", {"maxDepth":3,"maxStringLength":160})</script> <pre class=sf-dump id=sf-dump-1066952630 data-indent-pad="  ">"<span class=sf-dump-str title="14 characters">companies.show</span>"
</pre><script>Sfdump("sf-dump-1066952630", {"maxDepth":3,"maxStringLength":160})</script> <pre class=sf-dump id=sf-dump-247633342 data-indent-pad="  "><span class=sf-dump-note>App\Models\Company</span> {<a class=sf-dump-ref>#1644</a><samp data-depth=1 class=sf-dump-expanded>
  #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
  #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="9 characters">companies</span>"
  #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
  #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
  +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
  #<span class=sf-dump-protected title="Protected property">with</span>: []
  #<span class=sf-dump-protected title="Protected property">withCount</span>: []
  +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
  +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
  +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:12</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>id</span>" => <span class=sf-dump-num>3</span>
    "<span class=sf-dump-key>name</span>" => "<span class=sf-dump-str title="23 characters">COLIU IMPORT EXPORT SRL</span>"
    "<span class=sf-dump-key>cui</span>" => "<span class=sf-dump-str title="6 characters">410272</span>"
    "<span class=sf-dump-key>euid</span>" => "<span class=sf-dump-str title="20 characters">ROONRC.J40/5712/1992</span>"
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="19 characters">1992-03-11 17:31:22</span>"
    "<span class=sf-dump-key>type</span>" => "<span class=sf-dump-str title="3 characters">SRL</span>"
    "<span class=sf-dump-key>website</span>" => ""
    "<span class=sf-dump-key>parent_country</span>" => ""
    "<span class=sf-dump-key>mark</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>reg_com</span>" => "<span class=sf-dump-str title="13 characters">J40/5712/1992</span>"
    "<span class=sf-dump-key>created_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
    "<span class=sf-dump-key>updated_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:12</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>id</span>" => <span class=sf-dump-num>3</span>
    "<span class=sf-dump-key>name</span>" => "<span class=sf-dump-str title="23 characters">COLIU IMPORT EXPORT SRL</span>"
    "<span class=sf-dump-key>cui</span>" => "<span class=sf-dump-str title="6 characters">410272</span>"
    "<span class=sf-dump-key>euid</span>" => "<span class=sf-dump-str title="20 characters">ROONRC.J40/5712/1992</span>"
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="19 characters">1992-03-11 17:31:22</span>"
    "<span class=sf-dump-key>type</span>" => "<span class=sf-dump-str title="3 characters">SRL</span>"
    "<span class=sf-dump-key>website</span>" => ""
    "<span class=sf-dump-key>parent_country</span>" => ""
    "<span class=sf-dump-key>mark</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>reg_com</span>" => "<span class=sf-dump-str title="13 characters">J40/5712/1992</span>"
    "<span class=sf-dump-key>created_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
    "<span class=sf-dump-key>updated_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">changes</span>: []
  #<span class=sf-dump-protected title="Protected property">previous</span>: []
  #<span class=sf-dump-protected title="Protected property">casts</span>: <span class=sf-dump-note>array:1</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="4 characters">date</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
  #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
  #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
  #<span class=sf-dump-protected title="Protected property">appends</span>: []
  #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
  #<span class=sf-dump-protected title="Protected property">observables</span>: []
  #<span class=sf-dump-protected title="Protected property">relations</span>: <span class=sf-dump-note>array:7</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>address</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="App\Models\Address
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">App\Models</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Address</span></span> {<a class=sf-dump-ref>#2008</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
      #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="9 characters">addresses</span>"
      #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
      #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
      +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
      #<span class=sf-dump-protected title="Protected property">with</span>: []
      #<span class=sf-dump-protected title="Protected property">withCount</span>: []
      +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
      +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:16</span> [ &#8230;16]
      #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:16</span> [ &#8230;16]
      #<span class=sf-dump-protected title="Protected property">changes</span>: []
      #<span class=sf-dump-protected title="Protected property">previous</span>: []
      #<span class=sf-dump-protected title="Protected property">casts</span>: []
      #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">appends</span>: []
      #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
      #<span class=sf-dump-protected title="Protected property">observables</span>: []
      #<span class=sf-dump-protected title="Protected property">relations</span>: []
      #<span class=sf-dump-protected title="Protected property">touches</span>: []
      #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
      +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:4</span> [ &#8230;4]
      #<span class=sf-dump-protected title="Protected property">visible</span>: []
      #<span class=sf-dump-protected title="Protected property">fillable</span>: []
      #<span class=sf-dump-protected title="Protected property">guarded</span>: []
    </samp>}
    "<span class=sf-dump-key>info</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>status</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="App\Models\Status
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">App\Models</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Status</span></span> {<a class=sf-dump-ref>#2148</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
      #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="8 characters">statuses</span>"
      #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
      #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
      +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
      #<span class=sf-dump-protected title="Protected property">with</span>: []
      #<span class=sf-dump-protected title="Protected property">withCount</span>: []
      +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
      +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">changes</span>: []
      #<span class=sf-dump-protected title="Protected property">previous</span>: []
      #<span class=sf-dump-protected title="Protected property">casts</span>: []
      #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">appends</span>: []
      #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
      #<span class=sf-dump-protected title="Protected property">observables</span>: []
      #<span class=sf-dump-protected title="Protected property">relations</span>: <span class=sf-dump-note>array:1</span> [ &#8230;1]
      #<span class=sf-dump-protected title="Protected property">touches</span>: []
      #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
      +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">visible</span>: []
      #<span class=sf-dump-protected title="Protected property">fillable</span>: <span class=sf-dump-note>array:2</span> [ &#8230;2]
      #<span class=sf-dump-protected title="Protected property">guarded</span>: <span class=sf-dump-note>array:1</span> [ &#8230;1]
    </samp>}
    "<span class=sf-dump-key>caen</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#1291</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>legalRepresentatives</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#1367</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>naturalPersonRepresentatives</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#1843</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>euBranches</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#1101</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
  </samp>]
  #<span class=sf-dump-protected title="Protected property">touches</span>: []
  #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
  #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
  +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
  +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:3</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str title="10 characters">created_at</span>"
    <span class=sf-dump-index>1</span> => "<span class=sf-dump-str title="10 characters">updated_at</span>"
    <span class=sf-dump-index>2</span> => "<span class=sf-dump-str title="2 characters">id</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">visible</span>: []
  #<span class=sf-dump-protected title="Protected property">fillable</span>: <span class=sf-dump-note>array:10</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str title="4 characters">name</span>"
    <span class=sf-dump-index>1</span> => "<span class=sf-dump-str title="3 characters">cui</span>"
    <span class=sf-dump-index>2</span> => "<span class=sf-dump-str title="7 characters">reg_com</span>"
    <span class=sf-dump-index>3</span> => "<span class=sf-dump-str title="4 characters">euid</span>"
    <span class=sf-dump-index>4</span> => "<span class=sf-dump-str title="6 characters">status</span>"
    <span class=sf-dump-index>5</span> => "<span class=sf-dump-str title="17 characters">registration_date</span>"
    <span class=sf-dump-index>6</span> => "<span class=sf-dump-str title="4 characters">type</span>"
    <span class=sf-dump-index>7</span> => "<span class=sf-dump-str title="7 characters">website</span>"
    <span class=sf-dump-index>8</span> => "<span class=sf-dump-str title="14 characters">parent_country</span>"
    <span class=sf-dump-index>9</span> => "<span class=sf-dump-str title="4 characters">mark</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">guarded</span>: <span class=sf-dump-note>array:1</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str>*</span>"
  </samp>]
</samp>}
</pre><script>Sfdump("sf-dump-247633342", {"maxDepth":3,"maxStringLength":160})</script> 8.3.29 12.44.0 ro false true local a5562107215ff05a7fc40849695aea476b6008f5 Optimizare SEO: pagini individuale companii, meta taguri, harta siteului »ôi favicon v1.0 git@github.com:tudorr89/info-firme.git true    local null null /Users/tudor/Projects/info-firme null acbc93fa-b9ab-4cff-bf85-d26fc872df70 null null Laravel Client PHP 12.44.0 8.3.29 ParseError 1767511973 syntax error, unexpected end of file    /Users/tudor/Projects/info-firme/resources/views/components/seo-meta.blade.php 94 require null "postalCode": "{{ $company->address->postalCode ?? '' }}", "addressCountry": "RO" } @endif @if($company->info && $company->info->phone), ,"telephone": "{{ $company->info->phone }}" @endif } </script> @else <!-- Schema.org for Website with Search Action --> <script type="application/ld+json"> { "@context": "https://schema.org", "@type": "WebSite", "name": "lista-firme.info", "url": "{{ url('/') }}", "description": "CƒÉutare »ôi descoperire de informa»õii despre companii rom√¢ne»ôti", "potentialAction": { "@type": "SearchAction", "target": { "@type": "EntryPoint", "urlTemplate": "{{ url('/') }}?search={search_term_string}" }, "query-input": "required name=search_term_string" } } </script> @endif null  true /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php 123 Illuminate\Filesystem\{closure} Illuminate\Filesystem\Filesystem * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */ public function getRequire($path, array $data = []) { if ($this->isFile($path)) { $__path = $path; $__data = $data; null return (static function () use ($__path, $__data) { extract($__data, EXTR_SKIP); null return require $__path; })(); } null throw new FileNotFoundException("File does not exist at path {$path}."); } null /** * Require the given file once. * * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException arg0 /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php 124 getRequire Illuminate\Filesystem\Filesystem * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */ public function getRequire($path, array $data = []) { if ($this->isFile($path)) { $__path = $path; $__data = $data; null return (static function () use ($__path, $__data) { extract($__data, EXTR_SKIP); null return require $__path; })(); } null throw new FileNotFoundException("File does not exist at path {$path}."); } null /** * Require the given file once. * * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */  false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Engines/PhpEngine.php 57 evaluatePath Illuminate\View\Engines\PhpEngine * * @param  string  $path * @param  array  $data * @return string */ protected function evaluatePath($path, $data) { $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or // an exception is thrown. This prevents any partial views from leaking. try { $this->files->getRequire($path, $data); } catch (Throwable $e) { $this->handleViewException($e, $obLevel); } null return ltrim(ob_get_clean()); } null /** * Handle a view exception. * * @param  \Throwable  $e * @param  int  $obLevel * @return void * path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php 22 evaluatePath Livewire\Mechanisms\ExtendBlade\ExtendedCompilerEngine class ExtendedCompilerEngine extends \Illuminate\View\Engines\CompilerEngine { public function get($path, array $data = []) { if (! ExtendBlade::isRenderingLivewireComponent()) return parent::get($path, $data); null $currentComponent = ExtendBlade::currentRendering(); null trigger('view:compile', $currentComponent, $path); null return parent::get($path, $data); } null protected function evaluatePath($__path, $__data) { if (! ExtendBlade::isRenderingLivewireComponent()) { return parent::evaluatePath($__path, $__data); } null $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or // an exception is thrown. This prevents any partial views from leaking. try { $component = ExtendBlade::currentRendering(); null \Closure::bind(function () use ($__path, $__data) { extract($__data, EXTR_SKIP); path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Engines/CompilerEngine.php 76 get Illuminate\View\Engines\CompilerEngine { $this->lastCompiled[] = $path; null // If this given view has expired, which means it has simply been edited since // it was last compiled, we will re-compile the views so we can evaluate a // fresh copy of the view. We'll pass the compiler the path of the view. if (! isset($this->compiledOrNotExpired[$path]) && $this->compiler->isExpired($path)) { $this->compiler->compile($path); } null // Once we have the path to the compiled file, we will evaluate the paths with // typical PHP just like any other templates. We also keep a stack of views // which have been rendered for right exception messages to be generated. null try { $results = $this->evaluatePath($this->compiler->getCompiledPath($path), $data); } catch (ViewException $e) { if (! Str::of($e->getMessage())->contains(['No such file or directory', 'File does not exist at path'])) { throw $e; } null if (! isset($this->compiledOrNotExpired[$path])) { throw $e; } null $this->compiler->compile($path); null $results = $this->evaluatePath($this->compiler->getCompiledPath($path), $data); } null __path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false __data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php 10 get Livewire\Mechanisms\ExtendBlade\ExtendedCompilerEngine <?php null namespace Livewire\Mechanisms\ExtendBlade; null use function Livewire\trigger; null class ExtendedCompilerEngine extends \Illuminate\View\Engines\CompilerEngine { public function get($path, array $data = []) { if (! ExtendBlade::isRenderingLivewireComponent()) return parent::get($path, $data); null $currentComponent = ExtendBlade::currentRendering(); null trigger('view:compile', $currentComponent, $path); null return parent::get($path, $data); } null protected function evaluatePath($__path, $__data) { if (! ExtendBlade::isRenderingLivewireComponent()) { return parent::evaluatePath($__path, $__data); } null $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/ViewEngineDecorator.php 47 get Sentry\Laravel\Tracing\ViewEngineDecorator null // If there is no sampled span there is no need to wrap the engine call if ($parentSpan === null || !$parentSpan->getSampled()) { return $this->engine->get($path, $data); } null $span = $parentSpan->startChild( SpanContext::make() ->setOp('view.render') ->setOrigin('auto.view') ->setDescription($this->viewFactory->shared(self::SHARED_KEY, basename($path))) ); null SentrySdk::getCurrentHub()->setSpan($span); null $result = $this->engine->get($path, $data); null $span->finish(); null SentrySdk::getCurrentHub()->setSpan($parentSpan); null return $result; } null public function __call($name, $arguments) { return $this->engine->{$name}(...$arguments); } } null path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 208 getContents Illuminate\View\View // Once we've finished rendering the view, we'll decrement the render count // so that each section gets flushed out next time a view is created and // no old sections are staying around in the memory of an environment. $this->factory->decrementRender(); null return $contents; } null /** * Get the evaluated contents of the view. * * @return string */ protected function getContents() { return $this->engine->get($this->path, $this->gatherData()); } null /** * Get the data bound to the view instance. * * @return array */ public function gatherData() { $data = array_merge($this->factory->getShared(), $this->data); null foreach ($data as $key => $value) { if ($value instanceof Renderable) { $data[$key] = $value->render(); path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 191 renderContents Illuminate\View\View null /** * Get the contents of the view instance. * * @return string */ protected function renderContents() { // We will keep track of the number of views being rendered so we can flush // the section after the complete rendering operation is done. This will // clear out the sections for any separate views that may be rendered. $this->factory->incrementRender(); null $this->factory->callComposer($this); null $contents = $this->getContents(); null // Once we've finished rendering the view, we'll decrement the render count // so that each section gets flushed out next time a view is created and // no old sections are staying around in the memory of an environment. $this->factory->decrementRender(); null return $contents; } null /** * Get the evaluated contents of the view. * * @return string */  false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 160 render Illuminate\View\View { return (new Collection($this->render(fn () => $this->factory->getFragments())))->implode(''); } null /** * Get the string contents of the view. * * @param  callable|null  $callback * @return string * * @throws \Throwable */ public function render(?callable $callback = null) { try { $contents = $this->renderContents(); null $response = isset($callback) ? $callback($this, $contents) : null; null // Once we have the contents of the view, we will flush the sections if we are // done rendering all views so that there is nothing left hanging over when // another view gets rendered in the future by the application developer. $this->factory->flushStateIfDoneRendering(); null return ! is_null($response) ? $response : $contents; } catch (Throwable $e) { $this->factory->flushState(); null throw $e; }  false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Response.php 78 setContent Illuminate\Http\Response // from routes that will be automatically transformed to their JSON form. if ($this->shouldBeJson($content)) { $this->header('Content-Type', 'application/json'); null $content = $this->morphToJson($content); null if ($content === false) { throw new InvalidArgumentException(json_last_error_msg()); } } null // If this content implements the "Renderable" interface then we will call the // render method on the object so we will avoid any "__toString" exceptions // that might be thrown and have their errors obscured by PHP's handling. elseif ($content instanceof Renderable) { $content = $content->render(); } null parent::setContent($content); null return $this; } null /** * Determine if the given content should be turned into JSON. * * @param  mixed  $content * @return bool */ protected function shouldBeJson($content) callback null null false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Response.php 34 __construct Illuminate\Http\Response } null /** * Create a new HTTP response. * * @param  mixed  $content * @param  int  $status * @param  array  $headers * * @throws \InvalidArgumentException */ public function __construct($content = '', $status = 200, array $headers = []) { $this->headers = new ResponseHeaderBag($headers); null $this->setContent($content); $this->setStatusCode($status); $this->setProtocolVersion('1.0'); } null /** * Get the response content. */ #[\Override] public function getContent(): string|false { return transform(parent::getContent(), fn ($content) => $content, ''); } null /** null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 939 toResponse Illuminate\Routing\Router if ($response instanceof PsrResponseInterface) { $response = (new HttpFoundationFactory)->createResponse($response); } elseif ($response instanceof Model && $response->wasRecentlyCreated) { $response = new JsonResponse($response, 201); } elseif ($response instanceof Stringable) { $response = new Response($response->__toString(), 200, ['Content-Type' => 'text/html']); } elseif (! $response instanceof SymfonyResponse && ($response instanceof Arrayable || $response instanceof Jsonable || $response instanceof ArrayObject || $response instanceof JsonSerializable || $response instanceof stdClass || is_array($response))) { $response = new JsonResponse($response); } elseif (! $response instanceof SymfonyResponse) { $response = new Response($response, 200, ['Content-Type' => 'text/html']); } null if ($response->getStatusCode() === Response::HTTP_NOT_MODIFIED) { $response->setNotModified(); } null return $response->prepare($request); } null /** * Substitute the route bindings onto the route. * * @param  \Illuminate\Routing\Route  $route * @return \Illuminate\Routing\Route null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 906 prepareResponse Illuminate\Routing\Router { return (new SortedMiddleware($this->middlewarePriority, $middlewares))->all(); } null /** * Create a response instance from the given value. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @param  mixed  $response * @return \Symfony\Component\HttpFoundation\Response */ public function prepareResponse($request, $response) { $this->events->dispatch(new PreparingResponse($request, $response)); null return tap(static::toResponse($request, $response), function ($response) use ($request) { $this->events->dispatch(new ResponsePrepared($request, $response)); }); } null /** * Static version of prepareResponse. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @param  mixed  $response * @return \Symfony\Component\HttpFoundation\Response */ public static function toResponse($request, $response) { if ($response instanceof Responsable) { null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 821 Illuminate\Routing\{closure} Illuminate\Routing\Router * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; null $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddleware($route); null return (new Pipeline($this->container)) ->send($request) ->through($middleware) ->then(fn ($request) => $this->prepareResponse( $request, $route->run() )); } null /** * Gather the middleware for the given route with resolved class names. * * @param  \Illuminate\Routing\Route  $route * @return array */ public function gatherRouteMiddleware(Route $route) { return $this->resolveMiddleware($route->gatherMiddleware(), $route->excludedMiddleware()); } null false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 180 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline $this->finally = $callback; null return $this; } null /** * Get the final piece of the Closure onion. * * @param  \Closure  $destination * @return \Closure */ protected function prepareDestination(Closure $destination) { return function ($passable) use ($destination) { try { return $destination($passable); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; } null /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() { return function ($stack, $pipe) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/boost/src/Middleware/InjectBoost.php 22 handle Laravel\Boost\Middleware\InjectBoost use Closure; use Illuminate\Http\JsonResponse; use Illuminate\Http\RedirectResponse; use Illuminate\Http\Request; use Illuminate\View\View; use Laravel\Boost\Services\BrowserLogger; use Symfony\Component\HttpFoundation\BinaryFileResponse; use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpFoundation\StreamedResponse; null class InjectBoost { public function handle(Request $request, Closure $next): Response { /** @var Response $response */ $response = $next($request); null if ($this->shouldInject($response)) { $originalView = $response->original ?? null; $injectedContent = $this->injectScript($response->getContent()); $response->setContent($injectedContent); null if ($originalView instanceof View && property_exists($response, 'original')) { $response->original = $originalView; } } null return $response; } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:178-184 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Middleware/SubstituteBindings.php 50 handle Illuminate\Routing\Middleware\SubstituteBindings { $this->router = $router; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $route = $request->route(); null try { $this->router->substituteBindings($route); $this->router->substituteImplicitBindings($route); } catch (ModelNotFoundException $exception) { if ($route->getMissing()) { return $route->getMissing()($request, $exception); } null throw $exception; } null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/VerifyCsrfToken.php 87 handle Illuminate\Foundation\Http\Middleware\VerifyCsrfToken * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Illuminate\Session\TokenMismatchException */ public function handle($request, Closure $next) { if ( $this->isReading($request) || $this->runningUnitTests() || $this->inExceptArray($request) || $this->tokensMatch($request) ) { return tap($next($request), function ($response) use ($request) { if ($this->shouldAddXsrfTokenCookie()) { $this->addCookieToResponse($request, $response); } }); } null throw new TokenMismatchException('CSRF token mismatch.'); } null /** * Determine if the HTTP request uses a ‚Äòread‚Äô verb. * * @param  \Illuminate\Http\Request  $request * @return bool arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Middleware/ShareErrorsFromSession.php 48 handle Illuminate\View\Middleware\ShareErrorsFromSession */ public function __construct(ViewFactory $view) { $this->view = $view; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { // If the current session has an "errors" variable bound to it, we will share // its value with all view instances so the views can easily access errors // without having to bind. An empty bag is set when there aren't errors. $this->view->share( 'errors', $request->session()->get('errors') ?: new ViewErrorBag ); null // Putting the errors in the view for every view allows the developer to just // assume that some errors are always available, which is convenient since // they don't have to continually run checks for the presence of errors. null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php 120 handleStatefulRequest Illuminate\Session\Middleware\StartSession * @param  \Illuminate\Contracts\Session\Session  $session * @param  \Closure  $next * @return mixed */ protected function handleStatefulRequest(Request $request, $session, Closure $next) { // If a session driver has been configured, we will need to start the session here // so that the data is ready for an application. Note that the Laravel sessions // do not make use of PHP "native" sessions in any way since they are crappy. $request->setLaravelSession( $this->startSession($request, $session) ); null $this->collectGarbage($session); null $response = $next($request); null $this->storeCurrentUrl($request, $session); null $this->addCookieToResponse($response, $session); null // Again, if the session has been configured we will need to close out the session // so that the attributes may be persisted to some storage medium. We will also // add the session identifier cookie to the application response headers now. $this->saveSession($request); null return $response; } null /** arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php 63 handle Illuminate\Session\Middleware\StartSession * @return mixed */ public function handle($request, Closure $next) { if (! $this->sessionConfigured()) { return $next($request); } null $session = $this->getSession($request); null if ($this->manager->shouldBlock() || ($request->route() instanceof Route && $request->route()->locksFor())) { return $this->handleRequestWhileBlocking($request, $session, $next); } null return $this->handleStatefulRequest($request, $session, $next); } null /** * Handle the given request within session state. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Contracts\Session\Session  $session * @param  \Closure  $next * @return mixed */ protected function handleRequestWhileBlocking(Request $request, $session, Closure $next) { if (! $request->route() instanceof Route) { return; request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false session object Illuminate\Session\Store false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Cookie/Middleware/AddQueuedCookiesToResponse.php 36 handle Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse null /** * Create a new CookieQueue instance. * * @param  \Illuminate\Contracts\Cookie\QueueingFactory  $cookies */ public function __construct(CookieJar $cookies) { $this->cookies = $cookies; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); null foreach ($this->cookies->getQueuedCookies() as $cookie) { $response->headers->setCookie($cookie); } null return $response; } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Cookie/Middleware/EncryptCookies.php 74 handle Illuminate\Cookie\Middleware\EncryptCookies */ public function disableFor($name) { $this->except = array_merge($this->except, (array) $name); } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return \Symfony\Component\HttpFoundation\Response */ public function handle($request, Closure $next) { return $this->encrypt($next($this->decrypt($request))); } null /** * Decrypt the cookies on the request. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @return \Symfony\Component\HttpFoundation\Request */ protected function decrypt(Request $request) { foreach ($request->cookies as $key => $cookie) { if ($this->isDisabled($key)) { continue; } arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 137 then Illuminate\Pipeline\Pipeline /** * Run the pipeline with a final destination callback. * * @param  \Closure  $destination * @return mixed */ public function then(Closure $destination) { $pipeline = array_reduce( array_reverse($this->pipes()), $this->carry(), $this->prepareDestination($destination) ); null try { return $this->withinTransaction !== false ? $this->getContainer()->make('db')->connection($this->withinTransaction)->transaction(fn () => $pipeline($this->passable)) : $pipeline($this->passable); } finally { if ($this->finally) { ($this->finally)($this->passable); } } } null /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 821 runRouteWithinStack Illuminate\Routing\Router * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; null $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddleware($route); null return (new Pipeline($this->container)) ->send($request) ->through($middleware) ->then(fn ($request) => $this->prepareResponse( $request, $route->run() )); } null /** * Gather the middleware for the given route with resolved class names. * * @param  \Illuminate\Routing\Route  $route * @return array */ public function gatherRouteMiddleware(Route $route) { return $this->resolveMiddleware($route->gatherMiddleware(), $route->excludedMiddleware()); } destination /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php:821-823 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 800 runRoute Illuminate\Routing\Router null /** * Return the response for the given route. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Routing\Route  $route * @return \Symfony\Component\HttpFoundation\Response */ protected function runRoute(Request $request, Route $route) { $request->setRouteResolver(fn () => $route); null $this->events->dispatch(new RouteMatched($route, $request)); null return $this->prepareResponse($request, $this->runRouteWithinStack($route, $request) ); } null /** * Run the given route within a Stack "onion" instance. * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; route object Illuminate\Routing\Route false false false request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 764 dispatchToRoute Illuminate\Routing\Router public function dispatch(Request $request) { $this->currentRequest = $request; null return $this->dispatchToRoute($request); } null /** * Dispatch the request to a route and return the response. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatchToRoute(Request $request) { return $this->runRoute($request, $this->findRoute($request)); } null /** * Find the route matching a given request. * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Routing\Route */ protected function findRoute($request) { $this->events->dispatch(new Routing($request)); null $this->current = $route = $this->routes->match($request); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false route object Illuminate\Routing\Route false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 753 dispatch Illuminate\Routing\Router $route = tap($this->routes->getByName($name))->bind($this->currentRequest); null return $this->runRoute($this->currentRequest, $route); } null /** * Dispatch the request to the application. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatch(Request $request) { $this->currentRequest = $request; null return $this->dispatchToRoute($request); } null /** * Dispatch the request to a route and return the response. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatchToRoute(Request $request) { return $this->runRoute($request, $this->findRoute($request)); } null /** request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 200 Illuminate\Foundation\Http\{closure} Illuminate\Foundation\Http\Kernel if (! $this->app->hasBeenBootstrapped()) { $this->app->bootstrapWith($this->bootstrappers()); } } null /** * Get the route dispatcher callback. * * @return \Closure */ protected function dispatchToRouter() { return function ($request) { $this->app->instance('request', $request); null return $this->router->dispatch($request); }; } null /** * Call the terminate method on any terminable middleware. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Http\Response  $response * @return void */ public function terminate($request, $response) { $this->app['events']->dispatch(new Terminating); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 180 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline $this->finally = $callback; null return $this; } null /** * Get the final piece of the Closure onion. * * @param  \Closure  $destination * @return \Closure */ protected function prepareDestination(Closure $destination) { return function ($passable) use ($destination) { try { return $destination($passable); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; } null /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() { return function ($stack, $pipe) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/FlushEventsMiddleware.php 13 handle Sentry\Laravel\Http\FlushEventsMiddleware <?php null namespace Sentry\Laravel\Http; null use Closure; use Illuminate\Http\Request; use Sentry\Laravel\Integration; null class FlushEventsMiddleware { public function handle(Request $request, Closure $next) { return $next($request); } null public function terminate(Request $request, $response): void { Integration::flushEvents(); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:178-184 Closure false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestIpMiddleware.php 45 handle Sentry\Laravel\Http\SetRequestIpMiddleware * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure                 $next * * @return mixed */ public function handle(Request $request, Closure $next) { $container = Container::getInstance(); null if ($container->bound(HubInterface::class)) { /** @var \Sentry\State\HubInterface $sentry */ $sentry = $container->make(HubInterface::class); null $client = $sentry->getClient(); null if ($client !== null && $client->getOptions()->shouldSendDefaultPii()) { $sentry->configureScope(static function (Scope $scope) use ($request): void { $scope->setUser([ 'ip_address' => $request->ip(), ]); }); } } null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestMiddleware.php 31 handle Sentry\Laravel\Http\SetRequestMiddleware */ class SetRequestMiddleware { public function handle(Request $request, Closure $next) { $container = Container::getInstance(); null if ($container->bound(HubInterface::class)) { $psrRequest = $this->resolvePsrRequest($container); null if ($psrRequest !== null) { $container->instance(LaravelRequestFetcher::CONTAINER_PSR7_INSTANCE_KEY, $psrRequest); } } null return $next($request); } null private function resolvePsrRequest(Container $container): ?ServerRequestInterface { try { return $container->make(ServerRequestInterface::class); } catch (Throwable $e) { // Do not crash if there is an exception thrown while resolving the request object } null return null; } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Features/SupportDisablingBackButtonCache/DisableBackButtonCacheMiddleware.php 19 handle Livewire\Features\SupportDisablingBackButtonCache\DisableBackButtonCacheMiddleware null use Closure; use Symfony\Component\HttpFoundation\Response; null class DisableBackButtonCacheMiddleware { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); null if ($response instanceof Response && SupportDisablingBackButtonCache::$disableBackButtonCache){ $response->headers->add([ 'Pragma' => 'no-cache', 'Expires' => 'Fri, 01 Jan 1990 00:00:00 GMT', 'Cache-Control' => 'no-cache, must-revalidate, no-store, max-age=0, private', ]); null // We do flush this in the `SupportDisablingBackButtonCache` hook, but we // need to do it here as well to ensure that unit tests still work... SupportDisablingBackButtonCache::$disableBackButtonCache = false; } null return $response; arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php 21 handle Illuminate\Foundation\Http\Middleware\TransformsRequest use Symfony\Component\HttpFoundation\ParameterBag; null class TransformsRequest { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $this->clean($request); null return $next($request); } null /** * Clean the request's data. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function clean($request) { $this->cleanParameterBag($request->query); null if ($request->isJson()) { $this->cleanParameterBag($request->json()); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ConvertEmptyStringsToNull.php 31 handle Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { foreach (static::$skipCallbacks as $callback) { if ($callback($request)) { return $next($request); } } null return parent::handle($request, $next); } null /** * Transform the given value. * * @param  string  $key * @param  mixed  $value * @return mixed */ protected function transform($key, $value) { return $value === '' ? null : $value; } null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php 21 handle Illuminate\Foundation\Http\Middleware\TransformsRequest use Symfony\Component\HttpFoundation\ParameterBag; null class TransformsRequest { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $this->clean($request); null return $next($request); } null /** * Clean the request's data. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function clean($request) { $this->cleanParameterBag($request->query); null if ($request->isJson()) { $this->cleanParameterBag($request->json()); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TrimStrings.php 51 handle Illuminate\Foundation\Http\Middleware\TrimStrings /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { foreach (static::$skipCallbacks as $callback) { if ($callback($request)) { return $next($request); } } null return parent::handle($request, $next); } null /** * Transform the given value. * * @param  string  $key * @param  mixed  $value * @return mixed */ protected function transform($key, $value) { $except = array_merge($this->except, static::$neverTrim); null if ($this->shouldSkip($key, $except) || ! is_string($value)) { request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/ValidatePostSize.php 27 handle Illuminate\Http\Middleware\ValidatePostSize * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Illuminate\Http\Exceptions\PostTooLargeException */ public function handle($request, Closure $next) { $max = $this->getPostMaxSize(); null if ($max > 0 && $request->server('CONTENT_LENGTH') > $max) { throw new PostTooLargeException('The POST data is too large.'); } null return $next($request); } null /** * Determine the server 'post_max_size' as bytes. * * @return int */ protected function getPostMaxSize() { if (is_numeric($postMaxSize = ini_get('post_max_size'))) { return (int) $postMaxSize; } null $metric = strtoupper(substr($postMaxSize, -1)); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/PreventRequestsDuringMaintenance.php 109 handle Illuminate\Foundation\Http\Middleware\PreventRequestsDuringMaintenance return response( $data['template'], $data['status'] ?? 503, $this->getHeaders($data) ); } null throw new HttpException( $data['status'] ?? 503, 'Service Unavailable', null, $this->getHeaders($data) ); } null return $next($request); } null /** * Determine if the incoming request has a maintenance mode bypass cookie. * * @param  \Illuminate\Http\Request  $request * @param  array  $data * @return bool */ protected function hasValidBypassCookie($request, array $data) { return isset($data['secret']) && $request->cookie('laravel_maintenance') && MaintenanceModeBypassCookie::isValid( arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/HandleCors.php 48 handle Illuminate\Http\Middleware\HandleCors { $this->container = $container; $this->cors = $cors; } null /** * Handle the incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return \Illuminate\Http\Response */ public function handle($request, Closure $next) { if (! $this->hasMatchingPath($request)) { return $next($request); } null $this->cors->setOptions($this->container['config']->get('cors', [])); null if ($this->cors->isPreflightRequest($request)) { $response = $this->cors->handlePreflightRequest($request); null $this->cors->varyHeader($response, 'Access-Control-Request-Method'); null return $response; } null $response = $next($request); null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/TrustProxies.php 58 handle Illuminate\Http\Middleware\TrustProxies /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Symfony\Component\HttpKernel\Exception\HttpException */ public function handle(Request $request, Closure $next) { $request::setTrustedProxies([], $this->getTrustedHeaderNames()); null $this->setTrustedProxyIpAddresses($request); null return $next($request); } null /** * Sets the trusted proxies on the request. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function setTrustedProxyIpAddresses(Request $request) { $trustedIps = $this->proxies() ?: config('trustedproxy.proxies'); null if (is_null($trustedIps) && (laravel_cloud() || arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/Middleware.php 79 handle Sentry\Laravel\Tracing\Middleware null /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * * @return mixed */ public function handle(Request $request, Closure $next) { if (app()->bound(HubInterface::class)) { $this->startTransaction($request); } null return $next($request); } null /** * Handle the application termination. * * @param \Illuminate\Http\Request $request * @param mixed $response * * @return void */ public function terminate(Request $request, $response): void { // If there is no transaction there is nothing for us to do if ($this->transaction === null) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 137 then Illuminate\Pipeline\Pipeline /** * Run the pipeline with a final destination callback. * * @param  \Closure  $destination * @return mixed */ public function then(Closure $destination) { $pipeline = array_reduce( array_reverse($this->pipes()), $this->carry(), $this->prepareDestination($destination) ); null try { return $this->withinTransaction !== false ? $this->getContainer()->make('db')->connection($this->withinTransaction)->transaction(fn () => $pipeline($this->passable)) : $pipeline($this->passable); } finally { if ($this->finally) { ($this->finally)($this->passable); } } } null /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 175 sendRequestThroughRouter Illuminate\Foundation\Http\Kernel * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Http\Response */ protected function sendRequestThroughRouter($request) { $this->app->instance('request', $request); null Request::clearResolvedInstance(); null $this->bootstrap(); null return (new Pipeline($this->app)) ->send($request) ->through($this->app->shouldSkipMiddleware() ? [] : $this->middleware) ->then($this->dispatchToRouter()); } null /** * Bootstrap the application for HTTP requests. * * @return void */ public function bootstrap() { if (! $this->app->hasBeenBootstrapped()) { $this->app->bootstrapWith($this->bootstrappers()); } } null destination /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php:197-201 Closure false false false false /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 144 handle Illuminate\Foundation\Http\Kernel } null /** * Handle an incoming HTTP request. * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Http\Response */ public function handle($request) { $this->requestStartedAt = Carbon::now(); null try { $request->enableHttpMethodParameterOverride(); null $response = $this->sendRequestThroughRouter($request); } catch (Throwable $e) { $this->reportException($e); null $response = $this->renderException($request, $e); } null $this->app['events']->dispatch( new RequestHandled($request, $response) ); null return $response; } null /** request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false /Users/tudor/Projects/info-firme/public/index.php 51 require null | | Composer provides a convenient, automatically generated class loader for | this application. We just need to utilize it! We'll simply require it | into the script here so we don't need to manually load our classes. | */ null require __DIR__.'/../vendor/autoload.php'; null /* |-------------------------------------------------------------------------- | Run The Application |-------------------------------------------------------------------------- | | Once we have the application, we can handle the incoming request using | the application's HTTP kernel. Then, we will send the response back | to this client's browser, allowing them to enjoy our application. | */ null $app = require_once __DIR__.'/../bootstrap/app.php'; null $kernel = $app->make(Kernel::class); null $response = $kernel->handle( $request = Request::capture() )->send(); null $kernel->terminate($request, $response); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false true /Users/tudor/.composer/vendor/laravel/valet/server.php 110 [top] null $isPhpFile = pathinfo($uri, PATHINFO_EXTENSION) === 'php'; null if ($uri !== '/' && ! $isPhpFile && $staticFilePath = $valetDriver->isStaticFile($valetSitePath, $siteName, $uri)) { return $valetDriver->serveStaticFile($staticFilePath, $valetSitePath, $siteName, $uri); } null /** * Allow for drivers to take pre-loading actions (e.g. setting server variables). */ $valetDriver->beforeLoading($valetSitePath, $siteName, $uri); null /** * Attempt to dispatch to a front controller. */ $frontControllerPath = $valetDriver->frontControllerPath( $valetSitePath, $siteName, $uri ); null if (! $frontControllerPath) { if (isset($valetConfig['directory-listing']) && $valetConfig['directory-listing'] == 'on') { Server::showDirectoryListing($valetSitePath, $uri); } null Server::show404(); } null chdir(dirname($frontControllerPath)); null require $frontControllerPath; null  true https://info-firme.test/companie/410272 null GET Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36    info-firme.test <CENSORED> u=0, i en-US,en;q=0.9 gzip, deflate, br, zstd document ?1 navigate none text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36 1 "macOS" ?0 "Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24" no-cache no-cache uAXsyM05tx1x32aTeC4WkDxaO0P7k8tYKjJmZ84J vM3se5WQ0HWW2xKJndqeDDnC0KAHLR7OtAe15Hss uAXsyM05tx1x32aTeC4WkDxaO0P7k8tYKjJmZ84J https://info-firme.test/companie/410272 company.show   company.show 410272 App\Http\Controllers\CompanyController@show web /Users/tudor/Projects/info-firme/resources/views/components/seo-meta.blade.php <pre class=sf-dump id=sf-dump-1342951549 data-indent-pad="  "><span class=sf-dump-note>Illuminate\Support\ViewErrorBag</span> {<a class=sf-dump-ref>#1342</a><samp data-depth=1 class=sf-dump-expanded>
  #<span class=sf-dump-protected title="Protected property">bags</span>: []
</samp>}
</pre><script>Sfdump("sf-dump-1342951549", {"maxDepth":3,"maxStringLength":160})</script> <pre class=sf-dump id=sf-dump-1066952630 data-indent-pad="  ">"<span class=sf-dump-str title="14 characters">companies.show</span>"
</pre><script>Sfdump("sf-dump-1066952630", {"maxDepth":3,"maxStringLength":160})</script> <pre class=sf-dump id=sf-dump-247633342 data-indent-pad="  "><span class=sf-dump-note>App\Models\Company</span> {<a class=sf-dump-ref>#1644</a><samp data-depth=1 class=sf-dump-expanded>
  #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
  #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="9 characters">companies</span>"
  #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
  #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
  +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
  #<span class=sf-dump-protected title="Protected property">with</span>: []
  #<span class=sf-dump-protected title="Protected property">withCount</span>: []
  +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
  +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
  +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:12</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>id</span>" => <span class=sf-dump-num>3</span>
    "<span class=sf-dump-key>name</span>" => "<span class=sf-dump-str title="23 characters">COLIU IMPORT EXPORT SRL</span>"
    "<span class=sf-dump-key>cui</span>" => "<span class=sf-dump-str title="6 characters">410272</span>"
    "<span class=sf-dump-key>euid</span>" => "<span class=sf-dump-str title="20 characters">ROONRC.J40/5712/1992</span>"
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="19 characters">1992-03-11 17:31:22</span>"
    "<span class=sf-dump-key>type</span>" => "<span class=sf-dump-str title="3 characters">SRL</span>"
    "<span class=sf-dump-key>website</span>" => ""
    "<span class=sf-dump-key>parent_country</span>" => ""
    "<span class=sf-dump-key>mark</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>reg_com</span>" => "<span class=sf-dump-str title="13 characters">J40/5712/1992</span>"
    "<span class=sf-dump-key>created_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
    "<span class=sf-dump-key>updated_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:12</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>id</span>" => <span class=sf-dump-num>3</span>
    "<span class=sf-dump-key>name</span>" => "<span class=sf-dump-str title="23 characters">COLIU IMPORT EXPORT SRL</span>"
    "<span class=sf-dump-key>cui</span>" => "<span class=sf-dump-str title="6 characters">410272</span>"
    "<span class=sf-dump-key>euid</span>" => "<span class=sf-dump-str title="20 characters">ROONRC.J40/5712/1992</span>"
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="19 characters">1992-03-11 17:31:22</span>"
    "<span class=sf-dump-key>type</span>" => "<span class=sf-dump-str title="3 characters">SRL</span>"
    "<span class=sf-dump-key>website</span>" => ""
    "<span class=sf-dump-key>parent_country</span>" => ""
    "<span class=sf-dump-key>mark</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>reg_com</span>" => "<span class=sf-dump-str title="13 characters">J40/5712/1992</span>"
    "<span class=sf-dump-key>created_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
    "<span class=sf-dump-key>updated_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">changes</span>: []
  #<span class=sf-dump-protected title="Protected property">previous</span>: []
  #<span class=sf-dump-protected title="Protected property">casts</span>: <span class=sf-dump-note>array:1</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="4 characters">date</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
  #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
  #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
  #<span class=sf-dump-protected title="Protected property">appends</span>: []
  #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
  #<span class=sf-dump-protected title="Protected property">observables</span>: []
  #<span class=sf-dump-protected title="Protected property">relations</span>: <span class=sf-dump-note>array:7</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>address</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="App\Models\Address
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">App\Models</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Address</span></span> {<a class=sf-dump-ref>#2008</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
      #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="9 characters">addresses</span>"
      #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
      #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
      +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
      #<span class=sf-dump-protected title="Protected property">with</span>: []
      #<span class=sf-dump-protected title="Protected property">withCount</span>: []
      +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
      +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:16</span> [ &#8230;16]
      #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:16</span> [ &#8230;16]
      #<span class=sf-dump-protected title="Protected property">changes</span>: []
      #<span class=sf-dump-protected title="Protected property">previous</span>: []
      #<span class=sf-dump-protected title="Protected property">casts</span>: []
      #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">appends</span>: []
      #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
      #<span class=sf-dump-protected title="Protected property">observables</span>: []
      #<span class=sf-dump-protected title="Protected property">relations</span>: []
      #<span class=sf-dump-protected title="Protected property">touches</span>: []
      #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
      +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:4</span> [ &#8230;4]
      #<span class=sf-dump-protected title="Protected property">visible</span>: []
      #<span class=sf-dump-protected title="Protected property">fillable</span>: []
      #<span class=sf-dump-protected title="Protected property">guarded</span>: []
    </samp>}
    "<span class=sf-dump-key>info</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>status</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="App\Models\Status
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">App\Models</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Status</span></span> {<a class=sf-dump-ref>#2148</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
      #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="8 characters">statuses</span>"
      #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
      #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
      +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
      #<span class=sf-dump-protected title="Protected property">with</span>: []
      #<span class=sf-dump-protected title="Protected property">withCount</span>: []
      +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
      +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">changes</span>: []
      #<span class=sf-dump-protected title="Protected property">previous</span>: []
      #<span class=sf-dump-protected title="Protected property">casts</span>: []
      #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">appends</span>: []
      #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
      #<span class=sf-dump-protected title="Protected property">observables</span>: []
      #<span class=sf-dump-protected title="Protected property">relations</span>: <span class=sf-dump-note>array:1</span> [ &#8230;1]
      #<span class=sf-dump-protected title="Protected property">touches</span>: []
      #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
      +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">visible</span>: []
      #<span class=sf-dump-protected title="Protected property">fillable</span>: <span class=sf-dump-note>array:2</span> [ &#8230;2]
      #<span class=sf-dump-protected title="Protected property">guarded</span>: <span class=sf-dump-note>array:1</span> [ &#8230;1]
    </samp>}
    "<span class=sf-dump-key>caen</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#1291</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>legalRepresentatives</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#1367</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>naturalPersonRepresentatives</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#1843</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>euBranches</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#1101</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
  </samp>]
  #<span class=sf-dump-protected title="Protected property">touches</span>: []
  #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
  #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
  +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
  +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:3</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str title="10 characters">created_at</span>"
    <span class=sf-dump-index>1</span> => "<span class=sf-dump-str title="10 characters">updated_at</span>"
    <span class=sf-dump-index>2</span> => "<span class=sf-dump-str title="2 characters">id</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">visible</span>: []
  #<span class=sf-dump-protected title="Protected property">fillable</span>: <span class=sf-dump-note>array:10</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str title="4 characters">name</span>"
    <span class=sf-dump-index>1</span> => "<span class=sf-dump-str title="3 characters">cui</span>"
    <span class=sf-dump-index>2</span> => "<span class=sf-dump-str title="7 characters">reg_com</span>"
    <span class=sf-dump-index>3</span> => "<span class=sf-dump-str title="4 characters">euid</span>"
    <span class=sf-dump-index>4</span> => "<span class=sf-dump-str title="6 characters">status</span>"
    <span class=sf-dump-index>5</span> => "<span class=sf-dump-str title="17 characters">registration_date</span>"
    <span class=sf-dump-index>6</span> => "<span class=sf-dump-str title="4 characters">type</span>"
    <span class=sf-dump-index>7</span> => "<span class=sf-dump-str title="7 characters">website</span>"
    <span class=sf-dump-index>8</span> => "<span class=sf-dump-str title="14 characters">parent_country</span>"
    <span class=sf-dump-index>9</span> => "<span class=sf-dump-str title="4 characters">mark</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">guarded</span>: <span class=sf-dump-note>array:1</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str>*</span>"
  </samp>]
</samp>}
</pre><script>Sfdump("sf-dump-247633342", {"maxDepth":3,"maxStringLength":160})</script> 8.3.29 12.44.0 ro false true local a5562107215ff05a7fc40849695aea476b6008f5 Optimizare SEO: pagini individuale companii, meta taguri, harta siteului »ôi favicon v1.0 git@github.com:tudorr89/info-firme.git true    local null null /Users/tudor/Projects/info-firme null acbc93fa-b9ab-4cff-bf85-d26fc872df70 null null phpstorm auto false /Users/tudor/Projects/info-firme null true false / Clipboard %path:%line true Sublime subl://open?url=file://%path&line=%line TextMate txmt://open?url=file://%path&line=%line Emacs emacs://open?url=file://%path&line=%line MacVim mvim://open/?url=file://%path&line=%line PhpStorm phpstorm://open?file=%path&line=%line PHPStorm Remote javascript:r = new XMLHttpRequest;r.open("get", "http://localhost:63342/api/file/%path:%line");r.send() Idea idea://open?file=%path&line=%line VS Code vscode://file/%path:%line VS Code Insiders vscode-insiders://file/%path:%line VS Code Remote vscode://vscode-remote/%path:%line VS Code Insiders Remote vscode-insiders://vscode-remote/%path:%line VS Codium vscodium://file/%path:%line Cursor cursor://file/%path:%line Atom atom://core/open/file?filename=%path&line=%line Nova nova://open?path=%path&line=%line NetBeans netbeans://open/?f=%path:%line Xdebug xdebug://%path@%line https://flareapp.io/api/public-reports  /_ignition/update-config /Users/tudor/Projects/info-firme/resources/views/components/seo-meta.blade.php 94 require null "postalCode": "{{ $company->address->postalCode ?? '' }}", "addressCountry": "RO" } @endif @if($company->info && $company->info->phone), ,"telephone": "{{ $company->info->phone }}" @endif } </script> @else <!-- Schema.org for Website with Search Action --> <script type="application/ld+json"> { "@context": "https://schema.org", "@type": "WebSite", "name": "lista-firme.info", "url": "{{ url('/') }}", "description": "CƒÉutare »ôi descoperire de informa»õii despre companii rom√¢ne»ôti", "potentialAction": { "@type": "SearchAction", "target": { "@type": "EntryPoint", "urlTemplate": "{{ url('/') }}?search={search_term_string}" }, "query-input": "required name=search_term_string" } } </script> @endif null  true resources/views/components/seo-meta.blade.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php 123 Illuminate\Filesystem\{closure} Illuminate\Filesystem\Filesystem * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */ public function getRequire($path, array $data = []) { if ($this->isFile($path)) { $__path = $path; $__data = $data; null return (static function () use ($__path, $__data) { extract($__data, EXTR_SKIP); null return require $__path; })(); } null throw new FileNotFoundException("File does not exist at path {$path}."); } null /** * Require the given file once. * * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException arg0 /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false false vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php 124 getRequire Illuminate\Filesystem\Filesystem * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */ public function getRequire($path, array $data = []) { if ($this->isFile($path)) { $__path = $path; $__data = $data; null return (static function () use ($__path, $__data) { extract($__data, EXTR_SKIP); null return require $__path; })(); } null throw new FileNotFoundException("File does not exist at path {$path}."); } null /** * Require the given file once. * * @param  string  $path * @param  array  $data * @return mixed * * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException */  false vendor/laravel/framework/src/Illuminate/Filesystem/Filesystem.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Engines/PhpEngine.php 57 evaluatePath Illuminate\View\Engines\PhpEngine * * @param  string  $path * @param  array  $data * @return string */ protected function evaluatePath($path, $data) { $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or // an exception is thrown. This prevents any partial views from leaking. try { $this->files->getRequire($path, $data); } catch (Throwable $e) { $this->handleViewException($e, $obLevel); } null return ltrim(ob_get_clean()); } null /** * Handle a view exception. * * @param  \Throwable  $e * @param  int  $obLevel * @return void * path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false vendor/laravel/framework/src/Illuminate/View/Engines/PhpEngine.php /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php 22 evaluatePath Livewire\Mechanisms\ExtendBlade\ExtendedCompilerEngine class ExtendedCompilerEngine extends \Illuminate\View\Engines\CompilerEngine { public function get($path, array $data = []) { if (! ExtendBlade::isRenderingLivewireComponent()) return parent::get($path, $data); null $currentComponent = ExtendBlade::currentRendering(); null trigger('view:compile', $currentComponent, $path); null return parent::get($path, $data); } null protected function evaluatePath($__path, $__data) { if (! ExtendBlade::isRenderingLivewireComponent()) { return parent::evaluatePath($__path, $__data); } null $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or // an exception is thrown. This prevents any partial views from leaking. try { $component = ExtendBlade::currentRendering(); null \Closure::bind(function () use ($__path, $__data) { extract($__data, EXTR_SKIP); path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Engines/CompilerEngine.php 76 get Illuminate\View\Engines\CompilerEngine { $this->lastCompiled[] = $path; null // If this given view has expired, which means it has simply been edited since // it was last compiled, we will re-compile the views so we can evaluate a // fresh copy of the view. We'll pass the compiler the path of the view. if (! isset($this->compiledOrNotExpired[$path]) && $this->compiler->isExpired($path)) { $this->compiler->compile($path); } null // Once we have the path to the compiled file, we will evaluate the paths with // typical PHP just like any other templates. We also keep a stack of views // which have been rendered for right exception messages to be generated. null try { $results = $this->evaluatePath($this->compiler->getCompiledPath($path), $data); } catch (ViewException $e) { if (! Str::of($e->getMessage())->contains(['No such file or directory', 'File does not exist at path'])) { throw $e; } null if (! isset($this->compiledOrNotExpired[$path])) { throw $e; } null $this->compiler->compile($path); null $results = $this->evaluatePath($this->compiler->getCompiledPath($path), $data); } null __path /Users/tudor/Projects/info-firme/storage/framework/views/eb076c912d37fdefcc1463a406e9cef4.php string false false false __data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false vendor/laravel/framework/src/Illuminate/View/Engines/CompilerEngine.php /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php 10 get Livewire\Mechanisms\ExtendBlade\ExtendedCompilerEngine <?php null namespace Livewire\Mechanisms\ExtendBlade; null use function Livewire\trigger; null class ExtendedCompilerEngine extends \Illuminate\View\Engines\CompilerEngine { public function get($path, array $data = []) { if (! ExtendBlade::isRenderingLivewireComponent()) return parent::get($path, $data); null $currentComponent = ExtendBlade::currentRendering(); null trigger('view:compile', $currentComponent, $path); null return parent::get($path, $data); } null protected function evaluatePath($__path, $__data) { if (! ExtendBlade::isRenderingLivewireComponent()) { return parent::evaluatePath($__path, $__data); } null $obLevel = ob_get_level(); null ob_start(); null // We'll evaluate the contents of the view inside a try/catch block so we can // flush out any stray output that might get out before an error occurs or path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false vendor/livewire/livewire/src/Mechanisms/ExtendBlade/ExtendedCompilerEngine.php /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/ViewEngineDecorator.php 47 get Sentry\Laravel\Tracing\ViewEngineDecorator null // If there is no sampled span there is no need to wrap the engine call if ($parentSpan === null || !$parentSpan->getSampled()) { return $this->engine->get($path, $data); } null $span = $parentSpan->startChild( SpanContext::make() ->setOp('view.render') ->setOrigin('auto.view') ->setDescription($this->viewFactory->shared(self::SHARED_KEY, basename($path))) ); null SentrySdk::getCurrentHub()->setSpan($span); null $result = $this->engine->get($path, $data); null $span->finish(); null SentrySdk::getCurrentHub()->setSpan($parentSpan); null return $result; } null public function __call($name, $arguments) { return $this->engine->{$name}(...$arguments); } } null path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/ViewEngineDecorator.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 208 getContents Illuminate\View\View // Once we've finished rendering the view, we'll decrement the render count // so that each section gets flushed out next time a view is created and // no old sections are staying around in the memory of an environment. $this->factory->decrementRender(); null return $contents; } null /** * Get the evaluated contents of the view. * * @return string */ protected function getContents() { return $this->engine->get($this->path, $this->gatherData()); } null /** * Get the data bound to the view instance. * * @return array */ public function gatherData() { $data = array_merge($this->factory->getShared(), $this->data); null foreach ($data as $key => $value) { if ($value instanceof Renderable) { $data[$key] = $value->render(); path /Users/tudor/Projects/info-firme/resources/views/companies/show.blade.php string false false false data object (Illuminate\View\Factory) object (Illuminate\Foundation\Application) object (Illuminate\Support\ViewErrorBag) companies.show object (App\Models\Company) array false false false false vendor/laravel/framework/src/Illuminate/View/View.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 191 renderContents Illuminate\View\View null /** * Get the contents of the view instance. * * @return string */ protected function renderContents() { // We will keep track of the number of views being rendered so we can flush // the section after the complete rendering operation is done. This will // clear out the sections for any separate views that may be rendered. $this->factory->incrementRender(); null $this->factory->callComposer($this); null $contents = $this->getContents(); null // Once we've finished rendering the view, we'll decrement the render count // so that each section gets flushed out next time a view is created and // no old sections are staying around in the memory of an environment. $this->factory->decrementRender(); null return $contents; } null /** * Get the evaluated contents of the view. * * @return string */  false vendor/laravel/framework/src/Illuminate/View/View.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/View.php 160 render Illuminate\View\View { return (new Collection($this->render(fn () => $this->factory->getFragments())))->implode(''); } null /** * Get the string contents of the view. * * @param  callable|null  $callback * @return string * * @throws \Throwable */ public function render(?callable $callback = null) { try { $contents = $this->renderContents(); null $response = isset($callback) ? $callback($this, $contents) : null; null // Once we have the contents of the view, we will flush the sections if we are // done rendering all views so that there is nothing left hanging over when // another view gets rendered in the future by the application developer. $this->factory->flushStateIfDoneRendering(); null return ! is_null($response) ? $response : $contents; } catch (Throwable $e) { $this->factory->flushState(); null throw $e; }  false vendor/laravel/framework/src/Illuminate/View/View.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Response.php 78 setContent Illuminate\Http\Response // from routes that will be automatically transformed to their JSON form. if ($this->shouldBeJson($content)) { $this->header('Content-Type', 'application/json'); null $content = $this->morphToJson($content); null if ($content === false) { throw new InvalidArgumentException(json_last_error_msg()); } } null // If this content implements the "Renderable" interface then we will call the // render method on the object so we will avoid any "__toString" exceptions // that might be thrown and have their errors obscured by PHP's handling. elseif ($content instanceof Renderable) { $content = $content->render(); } null parent::setContent($content); null return $this; } null /** * Determine if the given content should be turned into JSON. * * @param  mixed  $content * @return bool */ protected function shouldBeJson($content) callback null null false false false false vendor/laravel/framework/src/Illuminate/Http/Response.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Response.php 34 __construct Illuminate\Http\Response } null /** * Create a new HTTP response. * * @param  mixed  $content * @param  int  $status * @param  array  $headers * * @throws \InvalidArgumentException */ public function __construct($content = '', $status = 200, array $headers = []) { $this->headers = new ResponseHeaderBag($headers); null $this->setContent($content); $this->setStatusCode($status); $this->setProtocolVersion('1.0'); } null /** * Get the response content. */ #[\Override] public function getContent(): string|false { return transform(parent::getContent(), fn ($content) => $content, ''); } null /** null false vendor/laravel/framework/src/Illuminate/Http/Response.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 939 toResponse Illuminate\Routing\Router if ($response instanceof PsrResponseInterface) { $response = (new HttpFoundationFactory)->createResponse($response); } elseif ($response instanceof Model && $response->wasRecentlyCreated) { $response = new JsonResponse($response, 201); } elseif ($response instanceof Stringable) { $response = new Response($response->__toString(), 200, ['Content-Type' => 'text/html']); } elseif (! $response instanceof SymfonyResponse && ($response instanceof Arrayable || $response instanceof Jsonable || $response instanceof ArrayObject || $response instanceof JsonSerializable || $response instanceof stdClass || is_array($response))) { $response = new JsonResponse($response); } elseif (! $response instanceof SymfonyResponse) { $response = new Response($response, 200, ['Content-Type' => 'text/html']); } null if ($response->getStatusCode() === Response::HTTP_NOT_MODIFIED) { $response->setNotModified(); } null return $response->prepare($request); } null /** * Substitute the route bindings onto the route. * * @param  \Illuminate\Routing\Route  $route * @return \Illuminate\Routing\Route null false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 906 prepareResponse Illuminate\Routing\Router { return (new SortedMiddleware($this->middlewarePriority, $middlewares))->all(); } null /** * Create a response instance from the given value. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @param  mixed  $response * @return \Symfony\Component\HttpFoundation\Response */ public function prepareResponse($request, $response) { $this->events->dispatch(new PreparingResponse($request, $response)); null return tap(static::toResponse($request, $response), function ($response) use ($request) { $this->events->dispatch(new ResponsePrepared($request, $response)); }); } null /** * Static version of prepareResponse. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @param  mixed  $response * @return \Symfony\Component\HttpFoundation\Response */ public static function toResponse($request, $response) { if ($response instanceof Responsable) { null false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 821 Illuminate\Routing\{closure} Illuminate\Routing\Router * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; null $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddleware($route); null return (new Pipeline($this->container)) ->send($request) ->through($middleware) ->then(fn ($request) => $this->prepareResponse( $request, $route->run() )); } null /** * Gather the middleware for the given route with resolved class names. * * @param  \Illuminate\Routing\Route  $route * @return array */ public function gatherRouteMiddleware(Route $route) { return $this->resolveMiddleware($route->gatherMiddleware(), $route->excludedMiddleware()); } null false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 180 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline $this->finally = $callback; null return $this; } null /** * Get the final piece of the Closure onion. * * @param  \Closure  $destination * @return \Closure */ protected function prepareDestination(Closure $destination) { return function ($passable) use ($destination) { try { return $destination($passable); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; } null /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() { return function ($stack, $pipe) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/boost/src/Middleware/InjectBoost.php 22 handle Laravel\Boost\Middleware\InjectBoost use Closure; use Illuminate\Http\JsonResponse; use Illuminate\Http\RedirectResponse; use Illuminate\Http\Request; use Illuminate\View\View; use Laravel\Boost\Services\BrowserLogger; use Symfony\Component\HttpFoundation\BinaryFileResponse; use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpFoundation\StreamedResponse; null class InjectBoost { public function handle(Request $request, Closure $next): Response { /** @var Response $response */ $response = $next($request); null if ($this->shouldInject($response)) { $originalView = $response->original ?? null; $injectedContent = $this->injectScript($response->getContent()); $response->setContent($injectedContent); null if ($originalView instanceof View && property_exists($response, 'original')) { $response->original = $originalView; } } null return $response; } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/boost/src/Middleware/InjectBoost.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:178-184 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Middleware/SubstituteBindings.php 50 handle Illuminate\Routing\Middleware\SubstituteBindings { $this->router = $router; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $route = $request->route(); null try { $this->router->substituteBindings($route); $this->router->substituteImplicitBindings($route); } catch (ModelNotFoundException $exception) { if ($route->getMissing()) { return $route->getMissing()($request, $exception); } null throw $exception; } null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Routing/Middleware/SubstituteBindings.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/VerifyCsrfToken.php 87 handle Illuminate\Foundation\Http\Middleware\VerifyCsrfToken * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Illuminate\Session\TokenMismatchException */ public function handle($request, Closure $next) { if ( $this->isReading($request) || $this->runningUnitTests() || $this->inExceptArray($request) || $this->tokensMatch($request) ) { return tap($next($request), function ($response) use ($request) { if ($this->shouldAddXsrfTokenCookie()) { $this->addCookieToResponse($request, $response); } }); } null throw new TokenMismatchException('CSRF token mismatch.'); } null /** * Determine if the HTTP request uses a ‚Äòread‚Äô verb. * * @param  \Illuminate\Http\Request  $request * @return bool arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/VerifyCsrfToken.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/View/Middleware/ShareErrorsFromSession.php 48 handle Illuminate\View\Middleware\ShareErrorsFromSession */ public function __construct(ViewFactory $view) { $this->view = $view; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { // If the current session has an "errors" variable bound to it, we will share // its value with all view instances so the views can easily access errors // without having to bind. An empty bag is set when there aren't errors. $this->view->share( 'errors', $request->session()->get('errors') ?: new ViewErrorBag ); null // Putting the errors in the view for every view allows the developer to just // assume that some errors are always available, which is convenient since // they don't have to continually run checks for the presence of errors. null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/View/Middleware/ShareErrorsFromSession.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php 120 handleStatefulRequest Illuminate\Session\Middleware\StartSession * @param  \Illuminate\Contracts\Session\Session  $session * @param  \Closure  $next * @return mixed */ protected function handleStatefulRequest(Request $request, $session, Closure $next) { // If a session driver has been configured, we will need to start the session here // so that the data is ready for an application. Note that the Laravel sessions // do not make use of PHP "native" sessions in any way since they are crappy. $request->setLaravelSession( $this->startSession($request, $session) ); null $this->collectGarbage($session); null $response = $next($request); null $this->storeCurrentUrl($request, $session); null $this->addCookieToResponse($response, $session); null // Again, if the session has been configured we will need to close out the session // so that the attributes may be persisted to some storage medium. We will also // add the session identifier cookie to the application response headers now. $this->saveSession($request); null return $response; } null /** arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php 63 handle Illuminate\Session\Middleware\StartSession * @return mixed */ public function handle($request, Closure $next) { if (! $this->sessionConfigured()) { return $next($request); } null $session = $this->getSession($request); null if ($this->manager->shouldBlock() || ($request->route() instanceof Route && $request->route()->locksFor())) { return $this->handleRequestWhileBlocking($request, $session, $next); } null return $this->handleStatefulRequest($request, $session, $next); } null /** * Handle the given request within session state. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Contracts\Session\Session  $session * @param  \Closure  $next * @return mixed */ protected function handleRequestWhileBlocking(Request $request, $session, Closure $next) { if (! $request->route() instanceof Route) { return; request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false session object Illuminate\Session\Store false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Cookie/Middleware/AddQueuedCookiesToResponse.php 36 handle Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse null /** * Create a new CookieQueue instance. * * @param  \Illuminate\Contracts\Cookie\QueueingFactory  $cookies */ public function __construct(CookieJar $cookies) { $this->cookies = $cookies; } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); null foreach ($this->cookies->getQueuedCookies() as $cookie) { $response->headers->setCookie($cookie); } null return $response; } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Cookie/Middleware/AddQueuedCookiesToResponse.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Cookie/Middleware/EncryptCookies.php 74 handle Illuminate\Cookie\Middleware\EncryptCookies */ public function disableFor($name) { $this->except = array_merge($this->except, (array) $name); } null /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return \Symfony\Component\HttpFoundation\Response */ public function handle($request, Closure $next) { return $this->encrypt($next($this->decrypt($request))); } null /** * Decrypt the cookies on the request. * * @param  \Symfony\Component\HttpFoundation\Request  $request * @return \Symfony\Component\HttpFoundation\Request */ protected function decrypt(Request $request) { foreach ($request->cookies as $key => $cookie) { if ($this->isDisabled($key)) { continue; } arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Cookie/Middleware/EncryptCookies.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 137 then Illuminate\Pipeline\Pipeline /** * Run the pipeline with a final destination callback. * * @param  \Closure  $destination * @return mixed */ public function then(Closure $destination) { $pipeline = array_reduce( array_reverse($this->pipes()), $this->carry(), $this->prepareDestination($destination) ); null try { return $this->withinTransaction !== false ? $this->getContainer()->make('db')->connection($this->withinTransaction)->transaction(fn () => $pipeline($this->passable)) : $pipeline($this->passable); } finally { if ($this->finally) { ($this->finally)($this->passable); } } } null /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 821 runRouteWithinStack Illuminate\Routing\Router * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; null $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddleware($route); null return (new Pipeline($this->container)) ->send($request) ->through($middleware) ->then(fn ($request) => $this->prepareResponse( $request, $route->run() )); } null /** * Gather the middleware for the given route with resolved class names. * * @param  \Illuminate\Routing\Route  $route * @return array */ public function gatherRouteMiddleware(Route $route) { return $this->resolveMiddleware($route->gatherMiddleware(), $route->excludedMiddleware()); } destination /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php:821-823 Closure false false false false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 800 runRoute Illuminate\Routing\Router null /** * Return the response for the given route. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Routing\Route  $route * @return \Symfony\Component\HttpFoundation\Response */ protected function runRoute(Request $request, Route $route) { $request->setRouteResolver(fn () => $route); null $this->events->dispatch(new RouteMatched($route, $request)); null return $this->prepareResponse($request, $this->runRouteWithinStack($route, $request) ); } null /** * Run the given route within a Stack "onion" instance. * * @param  \Illuminate\Routing\Route  $route * @param  \Illuminate\Http\Request  $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) { $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true; route object Illuminate\Routing\Route false false false request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 764 dispatchToRoute Illuminate\Routing\Router public function dispatch(Request $request) { $this->currentRequest = $request; null return $this->dispatchToRoute($request); } null /** * Dispatch the request to a route and return the response. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatchToRoute(Request $request) { return $this->runRoute($request, $this->findRoute($request)); } null /** * Find the route matching a given request. * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Routing\Route */ protected function findRoute($request) { $this->events->dispatch(new Routing($request)); null $this->current = $route = $this->routes->match($request); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false route object Illuminate\Routing\Route false false false false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Routing/Router.php 753 dispatch Illuminate\Routing\Router $route = tap($this->routes->getByName($name))->bind($this->currentRequest); null return $this->runRoute($this->currentRequest, $route); } null /** * Dispatch the request to the application. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatch(Request $request) { $this->currentRequest = $request; null return $this->dispatchToRoute($request); } null /** * Dispatch the request to a route and return the response. * * @param  \Illuminate\Http\Request  $request * @return \Symfony\Component\HttpFoundation\Response */ public function dispatchToRoute(Request $request) { return $this->runRoute($request, $this->findRoute($request)); } null /** request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Routing/Router.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 200 Illuminate\Foundation\Http\{closure} Illuminate\Foundation\Http\Kernel if (! $this->app->hasBeenBootstrapped()) { $this->app->bootstrapWith($this->bootstrappers()); } } null /** * Get the route dispatcher callback. * * @return \Closure */ protected function dispatchToRouter() { return function ($request) { $this->app->instance('request', $request); null return $this->router->dispatch($request); }; } null /** * Call the terminate method on any terminable middleware. * * @param  \Illuminate\Http\Request  $request * @param  \Illuminate\Http\Response  $response * @return void */ public function terminate($request, $response) { $this->app['events']->dispatch(new Terminating); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 180 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline $this->finally = $callback; null return $this; } null /** * Get the final piece of the Closure onion. * * @param  \Closure  $destination * @return \Closure */ protected function prepareDestination(Closure $destination) { return function ($passable) use ($destination) { try { return $destination($passable); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; } null /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() { return function ($stack, $pipe) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/FlushEventsMiddleware.php 13 handle Sentry\Laravel\Http\FlushEventsMiddleware <?php null namespace Sentry\Laravel\Http; null use Closure; use Illuminate\Http\Request; use Sentry\Laravel\Integration; null class FlushEventsMiddleware { public function handle(Request $request, Closure $next) { return $next($request); } null public function terminate(Request $request, $response): void { Integration::flushEvents(); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/FlushEventsMiddleware.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:178-184 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestIpMiddleware.php 45 handle Sentry\Laravel\Http\SetRequestIpMiddleware * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure                 $next * * @return mixed */ public function handle(Request $request, Closure $next) { $container = Container::getInstance(); null if ($container->bound(HubInterface::class)) { /** @var \Sentry\State\HubInterface $sentry */ $sentry = $container->make(HubInterface::class); null $client = $sentry->getClient(); null if ($client !== null && $client->getOptions()->shouldSendDefaultPii()) { $sentry->configureScope(static function (Scope $scope) use ($request): void { $scope->setUser([ 'ip_address' => $request->ip(), ]); }); } } null return $next($request); } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestIpMiddleware.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestMiddleware.php 31 handle Sentry\Laravel\Http\SetRequestMiddleware */ class SetRequestMiddleware { public function handle(Request $request, Closure $next) { $container = Container::getInstance(); null if ($container->bound(HubInterface::class)) { $psrRequest = $this->resolvePsrRequest($container); null if ($psrRequest !== null) { $container->instance(LaravelRequestFetcher::CONTAINER_PSR7_INSTANCE_KEY, $psrRequest); } } null return $next($request); } null private function resolvePsrRequest(Container $container): ?ServerRequestInterface { try { return $container->make(ServerRequestInterface::class); } catch (Throwable $e) { // Do not crash if there is an exception thrown while resolving the request object } null return null; } } null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/sentry/sentry-laravel/src/Sentry/Laravel/Http/SetRequestMiddleware.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/livewire/livewire/src/Features/SupportDisablingBackButtonCache/DisableBackButtonCacheMiddleware.php 19 handle Livewire\Features\SupportDisablingBackButtonCache\DisableBackButtonCacheMiddleware null use Closure; use Symfony\Component\HttpFoundation\Response; null class DisableBackButtonCacheMiddleware { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $response = $next($request); null if ($response instanceof Response && SupportDisablingBackButtonCache::$disableBackButtonCache){ $response->headers->add([ 'Pragma' => 'no-cache', 'Expires' => 'Fri, 01 Jan 1990 00:00:00 GMT', 'Cache-Control' => 'no-cache, must-revalidate, no-store, max-age=0, private', ]); null // We do flush this in the `SupportDisablingBackButtonCache` hook, but we // need to do it here as well to ensure that unit tests still work... SupportDisablingBackButtonCache::$disableBackButtonCache = false; } null return $response; arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/livewire/livewire/src/Features/SupportDisablingBackButtonCache/DisableBackButtonCacheMiddleware.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php 21 handle Illuminate\Foundation\Http\Middleware\TransformsRequest use Symfony\Component\HttpFoundation\ParameterBag; null class TransformsRequest { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $this->clean($request); null return $next($request); } null /** * Clean the request's data. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function clean($request) { $this->cleanParameterBag($request->query); null if ($request->isJson()) { $this->cleanParameterBag($request->json()); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ConvertEmptyStringsToNull.php 31 handle Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { foreach (static::$skipCallbacks as $callback) { if ($callback($request)) { return $next($request); } } null return parent::handle($request, $next); } null /** * Transform the given value. * * @param  string  $key * @param  mixed  $value * @return mixed */ protected function transform($key, $value) { return $value === '' ? null : $value; } null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/ConvertEmptyStringsToNull.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php 21 handle Illuminate\Foundation\Http\Middleware\TransformsRequest use Symfony\Component\HttpFoundation\ParameterBag; null class TransformsRequest { /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { $this->clean($request); null return $next($request); } null /** * Clean the request's data. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function clean($request) { $this->cleanParameterBag($request->query); null if ($request->isJson()) { $this->cleanParameterBag($request->json()); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TransformsRequest.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TrimStrings.php 51 handle Illuminate\Foundation\Http\Middleware\TrimStrings /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed */ public function handle($request, Closure $next) { foreach (static::$skipCallbacks as $callback) { if ($callback($request)) { return $next($request); } } null return parent::handle($request, $next); } null /** * Transform the given value. * * @param  string  $key * @param  mixed  $value * @return mixed */ protected function transform($key, $value) { $except = array_merge($this->except, static::$neverTrim); null if ($this->shouldSkip($key, $except) || ! is_string($value)) { request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/TrimStrings.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/ValidatePostSize.php 27 handle Illuminate\Http\Middleware\ValidatePostSize * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Illuminate\Http\Exceptions\PostTooLargeException */ public function handle($request, Closure $next) { $max = $this->getPostMaxSize(); null if ($max > 0 && $request->server('CONTENT_LENGTH') > $max) { throw new PostTooLargeException('The POST data is too large.'); } null return $next($request); } null /** * Determine the server 'post_max_size' as bytes. * * @return int */ protected function getPostMaxSize() { if (is_numeric($postMaxSize = ini_get('post_max_size'))) { return (int) $postMaxSize; } null $metric = strtoupper(substr($postMaxSize, -1)); arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Http/Middleware/ValidatePostSize.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/PreventRequestsDuringMaintenance.php 109 handle Illuminate\Foundation\Http\Middleware\PreventRequestsDuringMaintenance return response( $data['template'], $data['status'] ?? 503, $this->getHeaders($data) ); } null throw new HttpException( $data['status'] ?? 503, 'Service Unavailable', null, $this->getHeaders($data) ); } null return $next($request); } null /** * Determine if the incoming request has a maintenance mode bypass cookie. * * @param  \Illuminate\Http\Request  $request * @param  array  $data * @return bool */ protected function hasValidBypassCookie($request, array $data) { return isset($data['secret']) && $request->cookie('laravel_maintenance') && MaintenanceModeBypassCookie::isValid( arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/PreventRequestsDuringMaintenance.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/HandleCors.php 48 handle Illuminate\Http\Middleware\HandleCors { $this->container = $container; $this->cors = $cors; } null /** * Handle the incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return \Illuminate\Http\Response */ public function handle($request, Closure $next) { if (! $this->hasMatchingPath($request)) { return $next($request); } null $this->cors->setOptions($this->container['config']->get('cors', [])); null if ($this->cors->isPreflightRequest($request)) { $response = $this->cors->handlePreflightRequest($request); null $this->cors->varyHeader($response, 'Access-Control-Request-Method'); null return $response; } null $response = $next($request); null arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Http/Middleware/HandleCors.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Http/Middleware/TrustProxies.php 58 handle Illuminate\Http\Middleware\TrustProxies /** * Handle an incoming request. * * @param  \Illuminate\Http\Request  $request * @param  \Closure  $next * @return mixed * * @throws \Symfony\Component\HttpKernel\Exception\HttpException */ public function handle(Request $request, Closure $next) { $request::setTrustedProxies([], $this->getTrustedHeaderNames()); null $this->setTrustedProxyIpAddresses($request); null return $next($request); } null /** * Sets the trusted proxies on the request. * * @param  \Illuminate\Http\Request  $request * @return void */ protected function setTrustedProxyIpAddresses(Request $request) { $trustedIps = $this->proxies() ?: config('trustedproxy.proxies'); null if (is_null($trustedIps) && (laravel_cloud() || arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Http/Middleware/TrustProxies.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/Middleware.php 79 handle Sentry\Laravel\Tracing\Middleware null /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * * @return mixed */ public function handle(Request $request, Closure $next) { if (app()->bound(HubInterface::class)) { $this->startTransaction($request); } null return $next($request); } null /** * Handle the application termination. * * @param \Illuminate\Http\Request $request * @param mixed $response * * @return void */ public function terminate(Request $request, $response): void { // If there is no transaction there is nothing for us to do if ($this->transaction === null) { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/sentry/sentry-laravel/src/Sentry/Laravel/Tracing/Middleware.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 219 Illuminate\Pipeline\{closure} Illuminate\Pipeline\Pipeline null // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this->getContainer()->make($name); null $parameters = array_merge([$passable, $stack], $parameters); } else { // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; } null $carry = method_exists($pipe, $this->method) ? $pipe->{$this->method}(...$parameters) : $pipe(...$parameters); null return $this->handleCarry($carry); } catch (Throwable $e) { return $this->handleException($passable, $e); } }; }; } null /** * Parse full pipe string to get name and parameters. * * @param  string  $pipe request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false next /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php:195-226 Closure false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php 137 then Illuminate\Pipeline\Pipeline /** * Run the pipeline with a final destination callback. * * @param  \Closure  $destination * @return mixed */ public function then(Closure $destination) { $pipeline = array_reduce( array_reverse($this->pipes()), $this->carry(), $this->prepareDestination($destination) ); null try { return $this->withinTransaction !== false ? $this->getContainer()->make('db')->connection($this->withinTransaction)->transaction(fn () => $pipeline($this->passable)) : $pipeline($this->passable); } finally { if ($this->finally) { ($this->finally)($this->passable); } } } null /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() { arg0 GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Pipeline/Pipeline.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 175 sendRequestThroughRouter Illuminate\Foundation\Http\Kernel * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Http\Response */ protected function sendRequestThroughRouter($request) { $this->app->instance('request', $request); null Request::clearResolvedInstance(); null $this->bootstrap(); null return (new Pipeline($this->app)) ->send($request) ->through($this->app->shouldSkipMiddleware() ? [] : $this->middleware) ->then($this->dispatchToRouter()); } null /** * Bootstrap the application for HTTP requests. * * @return void */ public function bootstrap() { if (! $this->app->hasBeenBootstrapped()) { $this->app->bootstrapWith($this->bootstrappers()); } } null destination /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php:197-201 Closure false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php /Users/tudor/Projects/info-firme/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php 144 handle Illuminate\Foundation\Http\Kernel } null /** * Handle an incoming HTTP request. * * @param  \Illuminate\Http\Request  $request * @return \Illuminate\Http\Response */ public function handle($request) { $this->requestStartedAt = Carbon::now(); null try { $request->enableHttpMethodParameterOverride(); null $response = $this->sendRequestThroughRouter($request); } catch (Throwable $e) { $this->reportException($e); null $response = $this->renderException($request, $e); } null $this->app['events']->dispatch( new RequestHandled($request, $response) ); null return $response; } null /** request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false false vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php /Users/tudor/Projects/info-firme/public/index.php 51 require null | | Composer provides a convenient, automatically generated class loader for | this application. We just need to utilize it! We'll simply require it | into the script here so we don't need to manually load our classes. | */ null require __DIR__.'/../vendor/autoload.php'; null /* |-------------------------------------------------------------------------- | Run The Application |-------------------------------------------------------------------------- | | Once we have the application, we can handle the incoming request using | the application's HTTP kernel. Then, we will send the response back | to this client's browser, allowing them to enjoy our application. | */ null $app = require_once __DIR__.'/../bootstrap/app.php'; null $kernel = $app->make(Kernel::class); null $response = $kernel->handle( $request = Request::capture() )->send(); null $kernel->terminate($request, $response); null request GET https://info-firme.test/companie/410272 Illuminate\Http\Request false false false true public/index.php /Users/tudor/.composer/vendor/laravel/valet/server.php 110 [top] null $isPhpFile = pathinfo($uri, PATHINFO_EXTENSION) === 'php'; null if ($uri !== '/' && ! $isPhpFile && $staticFilePath = $valetDriver->isStaticFile($valetSitePath, $siteName, $uri)) { return $valetDriver->serveStaticFile($staticFilePath, $valetSitePath, $siteName, $uri); } null /** * Allow for drivers to take pre-loading actions (e.g. setting server variables). */ $valetDriver->beforeLoading($valetSitePath, $siteName, $uri); null /** * Attempt to dispatch to a front controller. */ $frontControllerPath = $valetDriver->frontControllerPath( $valetSitePath, $siteName, $uri ); null if (! $frontControllerPath) { if (isset($valetConfig['directory-listing']) && $valetConfig['directory-listing'] == 'on') { Server::showDirectoryListing($valetSitePath, $uri); } null Server::show404(); } null chdir(dirname($frontControllerPath)); null require $frontControllerPath; null  true /Users/tudor/.composer/vendor/laravel/valet/server.php https://info-firme.test/companie/410272 null GET Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36       null info-firme.test <CENSORED> u=0, i en-US,en;q=0.9 gzip, deflate, br, zstd document ?1 navigate none text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36 1 "macOS" ?0 "Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24" no-cache no-cache uAXsyM05tx1x32aTeC4WkDxaO0P7k8tYKjJmZ84J vM3se5WQ0HWW2xKJndqeDDnC0KAHLR7OtAe15Hss uAXsyM05tx1x32aTeC4WkDxaO0P7k8tYKjJmZ84J https://info-firme.test/companie/410272 company.show   8.3.29 12.44.0 ro false true local null company.show 410272 App\Http\Controllers\CompanyController@show web a5562107215ff05a7fc40849695aea476b6008f5 Optimizare SEO: pagini individuale companii, meta taguri, harta siteului »ôi favicon v1.0 git@github.com:tudorr89/info-firme.git true null /Users/tudor/Projects/info-firme/resources/views/components/seo-meta.blade.php <pre class=sf-dump id=sf-dump-1342951549 data-indent-pad="  "><span class=sf-dump-note>Illuminate\Support\ViewErrorBag</span> {<a class=sf-dump-ref>#1342</a><samp data-depth=1 class=sf-dump-expanded>
  #<span class=sf-dump-protected title="Protected property">bags</span>: []
</samp>}
</pre><script>Sfdump("sf-dump-1342951549", {"maxDepth":3,"maxStringLength":160})</script> <pre class=sf-dump id=sf-dump-1066952630 data-indent-pad="  ">"<span class=sf-dump-str title="14 characters">companies.show</span>"
</pre><script>Sfdump("sf-dump-1066952630", {"maxDepth":3,"maxStringLength":160})</script> <pre class=sf-dump id=sf-dump-247633342 data-indent-pad="  "><span class=sf-dump-note>App\Models\Company</span> {<a class=sf-dump-ref>#1644</a><samp data-depth=1 class=sf-dump-expanded>
  #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
  #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="9 characters">companies</span>"
  #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
  #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
  +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
  #<span class=sf-dump-protected title="Protected property">with</span>: []
  #<span class=sf-dump-protected title="Protected property">withCount</span>: []
  +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
  +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
  +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:12</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>id</span>" => <span class=sf-dump-num>3</span>
    "<span class=sf-dump-key>name</span>" => "<span class=sf-dump-str title="23 characters">COLIU IMPORT EXPORT SRL</span>"
    "<span class=sf-dump-key>cui</span>" => "<span class=sf-dump-str title="6 characters">410272</span>"
    "<span class=sf-dump-key>euid</span>" => "<span class=sf-dump-str title="20 characters">ROONRC.J40/5712/1992</span>"
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="19 characters">1992-03-11 17:31:22</span>"
    "<span class=sf-dump-key>type</span>" => "<span class=sf-dump-str title="3 characters">SRL</span>"
    "<span class=sf-dump-key>website</span>" => ""
    "<span class=sf-dump-key>parent_country</span>" => ""
    "<span class=sf-dump-key>mark</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>reg_com</span>" => "<span class=sf-dump-str title="13 characters">J40/5712/1992</span>"
    "<span class=sf-dump-key>created_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
    "<span class=sf-dump-key>updated_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:12</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>id</span>" => <span class=sf-dump-num>3</span>
    "<span class=sf-dump-key>name</span>" => "<span class=sf-dump-str title="23 characters">COLIU IMPORT EXPORT SRL</span>"
    "<span class=sf-dump-key>cui</span>" => "<span class=sf-dump-str title="6 characters">410272</span>"
    "<span class=sf-dump-key>euid</span>" => "<span class=sf-dump-str title="20 characters">ROONRC.J40/5712/1992</span>"
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="19 characters">1992-03-11 17:31:22</span>"
    "<span class=sf-dump-key>type</span>" => "<span class=sf-dump-str title="3 characters">SRL</span>"
    "<span class=sf-dump-key>website</span>" => ""
    "<span class=sf-dump-key>parent_country</span>" => ""
    "<span class=sf-dump-key>mark</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>reg_com</span>" => "<span class=sf-dump-str title="13 characters">J40/5712/1992</span>"
    "<span class=sf-dump-key>created_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
    "<span class=sf-dump-key>updated_at</span>" => "<span class=sf-dump-str title="19 characters">2026-01-03 17:31:22</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">changes</span>: []
  #<span class=sf-dump-protected title="Protected property">previous</span>: []
  #<span class=sf-dump-protected title="Protected property">casts</span>: <span class=sf-dump-note>array:1</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>registration_date</span>" => "<span class=sf-dump-str title="4 characters">date</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
  #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
  #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
  #<span class=sf-dump-protected title="Protected property">appends</span>: []
  #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
  #<span class=sf-dump-protected title="Protected property">observables</span>: []
  #<span class=sf-dump-protected title="Protected property">relations</span>: <span class=sf-dump-note>array:7</span> [<samp data-depth=2 class=sf-dump-compact>
    "<span class=sf-dump-key>address</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="App\Models\Address
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">App\Models</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Address</span></span> {<a class=sf-dump-ref>#2008</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
      #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="9 characters">addresses</span>"
      #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
      #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
      +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
      #<span class=sf-dump-protected title="Protected property">with</span>: []
      #<span class=sf-dump-protected title="Protected property">withCount</span>: []
      +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
      +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:16</span> [ &#8230;16]
      #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:16</span> [ &#8230;16]
      #<span class=sf-dump-protected title="Protected property">changes</span>: []
      #<span class=sf-dump-protected title="Protected property">previous</span>: []
      #<span class=sf-dump-protected title="Protected property">casts</span>: []
      #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">appends</span>: []
      #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
      #<span class=sf-dump-protected title="Protected property">observables</span>: []
      #<span class=sf-dump-protected title="Protected property">relations</span>: []
      #<span class=sf-dump-protected title="Protected property">touches</span>: []
      #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
      +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:4</span> [ &#8230;4]
      #<span class=sf-dump-protected title="Protected property">visible</span>: []
      #<span class=sf-dump-protected title="Protected property">fillable</span>: []
      #<span class=sf-dump-protected title="Protected property">guarded</span>: []
    </samp>}
    "<span class=sf-dump-key>info</span>" => <span class=sf-dump-const>null</span>
    "<span class=sf-dump-key>status</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="App\Models\Status
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">App\Models</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Status</span></span> {<a class=sf-dump-ref>#2148</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">connection</span>: "<span class=sf-dump-str title="5 characters">mysql</span>"
      #<span class=sf-dump-protected title="Protected property">table</span>: "<span class=sf-dump-str title="8 characters">statuses</span>"
      #<span class=sf-dump-protected title="Protected property">primaryKey</span>: "<span class=sf-dump-str title="2 characters">id</span>"
      #<span class=sf-dump-protected title="Protected property">keyType</span>: "<span class=sf-dump-str title="3 characters">int</span>"
      +<span class=sf-dump-public title="Public property">incrementing</span>: <span class=sf-dump-const>true</span>
      #<span class=sf-dump-protected title="Protected property">with</span>: []
      #<span class=sf-dump-protected title="Protected property">withCount</span>: []
      +<span class=sf-dump-public title="Public property">preventsLazyLoading</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">perPage</span>: <span class=sf-dump-num>15</span>
      +<span class=sf-dump-public title="Public property">exists</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">wasRecentlyCreated</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">attributes</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">original</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">changes</span>: []
      #<span class=sf-dump-protected title="Protected property">previous</span>: []
      #<span class=sf-dump-protected title="Protected property">casts</span>: []
      #<span class=sf-dump-protected title="Protected property">classCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">attributeCastCache</span>: []
      #<span class=sf-dump-protected title="Protected property">dateFormat</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">appends</span>: []
      #<span class=sf-dump-protected title="Protected property">dispatchesEvents</span>: []
      #<span class=sf-dump-protected title="Protected property">observables</span>: []
      #<span class=sf-dump-protected title="Protected property">relations</span>: <span class=sf-dump-note>array:1</span> [ &#8230;1]
      #<span class=sf-dump-protected title="Protected property">touches</span>: []
      #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
      #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
      +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
      +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
      #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:5</span> [ &#8230;5]
      #<span class=sf-dump-protected title="Protected property">visible</span>: []
      #<span class=sf-dump-protected title="Protected property">fillable</span>: <span class=sf-dump-note>array:2</span> [ &#8230;2]
      #<span class=sf-dump-protected title="Protected property">guarded</span>: <span class=sf-dump-note>array:1</span> [ &#8230;1]
    </samp>}
    "<span class=sf-dump-key>caen</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#1291</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>legalRepresentatives</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#1367</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>naturalPersonRepresentatives</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#1843</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
    "<span class=sf-dump-key>euBranches</span>" => <span class="sf-dump-note sf-dump-ellipsization" title="Illuminate\Database\Eloquent\Collection
"><span class="sf-dump-ellipsis sf-dump-ellipsis-note">Illuminate\Database\Eloquent</span><span class="sf-dump-ellipsis sf-dump-ellipsis-note">\</span><span class="sf-dump-ellipsis-tail">Collection</span></span> {<a class=sf-dump-ref>#1101</a><samp data-depth=3 class=sf-dump-compact>
      #<span class=sf-dump-protected title="Protected property">items</span>: []
      #<span class=sf-dump-protected title="Protected property">escapeWhenCastingToString</span>: <span class=sf-dump-const>false</span>
    </samp>}
  </samp>]
  #<span class=sf-dump-protected title="Protected property">touches</span>: []
  #<span class=sf-dump-protected title="Protected property">relationAutoloadCallback</span>: <span class=sf-dump-const>null</span>
  #<span class=sf-dump-protected title="Protected property">relationAutoloadContext</span>: <span class=sf-dump-const>null</span>
  +<span class=sf-dump-public title="Public property">timestamps</span>: <span class=sf-dump-const>true</span>
  +<span class=sf-dump-public title="Public property">usesUniqueIds</span>: <span class=sf-dump-const>false</span>
  #<span class=sf-dump-protected title="Protected property">hidden</span>: <span class=sf-dump-note>array:3</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str title="10 characters">created_at</span>"
    <span class=sf-dump-index>1</span> => "<span class=sf-dump-str title="10 characters">updated_at</span>"
    <span class=sf-dump-index>2</span> => "<span class=sf-dump-str title="2 characters">id</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">visible</span>: []
  #<span class=sf-dump-protected title="Protected property">fillable</span>: <span class=sf-dump-note>array:10</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str title="4 characters">name</span>"
    <span class=sf-dump-index>1</span> => "<span class=sf-dump-str title="3 characters">cui</span>"
    <span class=sf-dump-index>2</span> => "<span class=sf-dump-str title="7 characters">reg_com</span>"
    <span class=sf-dump-index>3</span> => "<span class=sf-dump-str title="4 characters">euid</span>"
    <span class=sf-dump-index>4</span> => "<span class=sf-dump-str title="6 characters">status</span>"
    <span class=sf-dump-index>5</span> => "<span class=sf-dump-str title="17 characters">registration_date</span>"
    <span class=sf-dump-index>6</span> => "<span class=sf-dump-str title="4 characters">type</span>"
    <span class=sf-dump-index>7</span> => "<span class=sf-dump-str title="7 characters">website</span>"
    <span class=sf-dump-index>8</span> => "<span class=sf-dump-str title="14 characters">parent_country</span>"
    <span class=sf-dump-index>9</span> => "<span class=sf-dump-str title="4 characters">mark</span>"
  </samp>]
  #<span class=sf-dump-protected title="Protected property">guarded</span>: <span class=sf-dump-note>array:1</span> [<samp data-depth=2 class=sf-dump-compact>
    <span class=sf-dump-index>0</span> => "<span class=sf-dump-str>*</span>"
  </samp>]
</samp>}
</pre><script>Sfdump("sf-dump-247633342", {"maxDepth":3,"maxStringLength":160})</script> null null null  web https://info-firme.test/companie/410272 ParseError syntax error, unexpected end of file /Users/tudor/Projects/info-firme null 8.3.29 12.44.0 Flare local null require    {"url":"https://info-firme.test/companie/410272","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36","timestamp":"2026-01-04T07:32:53.228Z"} 
